" Modeline & Notes {{{
" vim: set sw=4 ts=4 sts=4 et tw=79 foldlevel=0 foldmethod=marker foldmarker={{{,}}}:
"
" My .vimrc - Always needs lots of work. See the TODO section for things on
" the list.
"
"   Development Notes {{{
"     Debugging: Can insert 'echom "<msg>"' to show mesages in the cmd window.
"     These typically will disappear when output from .vimrc but can be
"     displayed with ':messages'.
"
"     An interesting vim debugging link:
"         https://codeinthehole.com/tips/debugging-vim-by-example/
"
"   }}}
" }}}

" Environment {{{
    if &compatible
      set nocompatible
    endif

    silent function! OSX()
        return has('macunix')
    endfunction

    silent function! LINUX()
        return has('unix') && !has('macunix') && !has('win32unix')
    endfunction

    silent function! WINDOWS()
        return  (has('win32') || has('win64'))
    endfunction

    if WINDOWS()
        set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
    endif

    "
    " Create a '~/.vim/python' symlink to python home to turn this on...
    " python -> ~/.asdf/installs/python/3.7.3-framework-vim/Python.framework/Versions/3.7
    "
    " Install neovim in python env:
    "   $ pip install neovim
    "
    
    "
    " This seems to be fraught with peril... things seem to work just fine, and
    " then I'll start to get weird errors. I don't believe the answer
    " necessarily lies here, but it may:
    "
    "    https://www.bountysource.com/issues/42900279-could-not-find-neovim
    "
    if isdirectory($HOME . '/.vim/python') && !exists('s:python_initialized')
        set pythonthreehome=$HOME/.vim/python
        " Setting 'pythonthreehome' seems to be enough for the dll as well.
        "set pythonthreedll=$HOME/.vim/python/lib/libpython3.7.dylib
        let $PATH = $HOME . '/.vim/python/bin:' . $PATH
        let s:python_initialized = 1
    endif
" }}}

" Install Plugins {{{
    call plug#begin('~/.vim/plugged')

        Plug 'Shougo/deoplete.nvim'

        if !has('nvim')
            Plug 'roxma/nvim-yarp'
            Plug 'roxma/vim-hug-neovim-rpc'
        endif

        Plug 'vim-airline/vim-airline'
        Plug 'vim-airline/vim-airline-themes'
        Plug 'flazz/vim-colorschemes'

        Plug 'Shougo/denite.nvim', { 'tag': '3.0' }
        Plug 'Shougo/defx.nvim', { 'tag': '1.0' }

        Plug 'tpope/vim-abolish'
        Plug 'tpope/vim-fugitive'
        Plug 'tpope/vim-surround'
        
        Plug 'jeetsukumaran/vim-buffergator'
        
        Plug 'rodjek/vim-puppet'
        Plug 'markcornick/vim-terraform'
        Plug 'lmeijvogel/vim-yaml-helper'
        
        Plug 'luochen1990/rainbow'
        Plug 'mtth/scratch.vim'
        Plug 'ervandew/supertab'
        Plug 'scrooloose/syntastic'
        Plug 'godlygeek/tabular'
        Plug 'tomtom/tcomment_vim'
        
        Plug 'jiangmiao/auto-pairs'
        
        Plug 'vim-scripts/groovyindent-unix'
        
        Plug 'vimwiki/vimwiki'
    call plug#end()

    if exists("g:plugin_install") && g:plugin_install == 1 
        finish
    endif
" }}}

" General {{{
    filetype plugin indent on
    syntax enable

    scriptencoding utf-8
    set encoding=utf-8

    set fileformats=unix 
    set history=100
    set ttyfast                             

    set nofileignorecase                    "case-sensitive file completion

    set ruler                               "show cursor position

    set scrolloff=3                         "context lines when scrolling
    set sidescrolloff=5                     "context columns when scrolling

    set laststatus=2                        "always show status line
    set showmode                            "display mode at bottom of screen
    set showcmd                             "show commands at bottom of screen

    set cursorline                          "hightlight current line
    set colorcolumn=81                      "make 80 columns obvious

    set nostartofline                       "try to leave cursor in same column
    set virtualedit=all                     "allow cursor where no actual characters exist

    set backspace=indent,eol,start          "a better backspace

    set autoread                            "detect external file changes
    set hidden                              "change buffers without saving

    set showmatch                           "show matching character pair

    "set wildmenu                            "enhanced autocomplete
    "set wildmode=longest,list,full          "autocomplete behavior
    set wildmenu                            "enhanced autocomplete
    set wildmode=longest,full               "autocomplete behavior

    set ignorecase                          "ignore case in search, regex
    set smartcase                           "only ignore case if pattern is all lower

    set hlsearch                            "highlight search results
    set incsearch                           "search incremntally

    set shortmess+=filmnrxoOtT              "abbreviate messages (avoids 'hit enter')
    set cmdheight=1                         "command line rows

    set autoindent                          "indent at same level as previous line
    set smartindent                         "add indent for code blocks

    set expandtab                           "tabs as spaces
    set shiftwidth=4
    set softtabstop=4

    autocmd BufEnter * silent! lcd %:p:h    "cwd tracks current file

    " Silence the bell.
    set noerrorbells visualbell t_vb=
    autocmd GUIEnter * set visualbell t_vb=

    if has('clipboard')
        if has('unnamedplus')  
            " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        else         
            " On mac and Windows, use * register for copy-paste
            set clipboard=unnamed
        endif
    endif

    " Directories
    set backupdir=~/.vim/.backup//
    set directory=~/.vim/.swp//
    set undodir=~/.vim/.undo//
    set viewdir=~/.vim/.view

    " Strip trailing whitespace from these files.
    augroup whitespace
        autocmd!
        autocmd FileType groovy,java,python,puppet,ruby,terraform 
            \ autocmd BufWritePre <buffer> %s/\s\+$//e
    augroup END
" }}}

" UI {{{

    " GUI {{{

        if has("gui_running")

           " 
           " For a good resource regarding how to pick and set a font, see:
           "
           "   http://www.scholarslab.org/grad-student-research/vim-gui-font-magic/
           "

           if OSX()
               set guifont=Sauce\ Code\ Powerline:h18
               set columns=160
               set lines=48
           elseif LINUX()
               set guifont=Source\ Code\ Pro\ for\ Powerline\ Medium\ 10
               set columns=120
               set lines=52
           else
               set guifont="Courier 10 Pitch":h10
               set columns=120
               set lines=64
           endif

           set guioptions-=T           " turn off the toolbar
           set guioptions-=l           " no scrollbars on the left
           set guioptions-=L           " no scrollbars on the left
           set guioptions-=r           " no scrollbars on the right
           set guioptions-=R           " no scrollbars on the right
        endif
    " }}}

    " {{{ colorscheme 
        " set background=light

        if has("gui_running")
            " colorscheme onedark
            " colorscheme professional
            " colorscheme molokai
            " colorscheme solarized
            " colorscheme desert
            " colorscheme neodark
            colorscheme quantum
        else
            colorscheme molokai
        endif
        
        "
        " I'm not interested in creating my own versions of various color
        " schemes. I do, however, want to be able to tweak the ones I use if
        " necessary, so we'll do that here.
        "
        " TODO: Is there a better way to achieve the tweaks we want?
        " 

        "
        " Got the following colorscheme stuff from:
        "
        " https://github.com/megaannum/colorschemer/blob/master/autoload/colorschemer/viewer.vim
        "

        let s:colorsname = ""

        function! s:GetColorSchemeName()
          if exists("g:colors_name")
            return g:colors_name
          else
            if exists("s:colorsname")
              unlet s:colorsname
            endif

            execute "redir => s:colorsname"
            silent execute "colorscheme"
            execute "redir END"
            let s:colorsname = s:colorsname[1:]
            return s:colorsname
          endif
        endfunction
        
        let cname = s:GetColorSchemeName()
        
        if cname == 'molokai'
            " Better cursor line colors.
            highlight CursorLine guibg=Gray27 ctermbg=238
            highlight CursorColumn guibg=Gray27 ctermbg=238
        
            " Default column color (i.e. column 80 indicator) sucks (it's red!).
            " highlight ColorColumn guibg=DarkSlateGray
        
            " Default comment color too dark.
            highlight Comment guifg=SkyBlue3 ctermfg=67
        
            " Default visual selection needs more contrast.
            highlight Visual guifg=Gray30 guibg=NavajoWhite
            " highlight Visual guibg=gray30
        elseif cname == 'neodark'
            highlight Normal guibg=gray18
        elseif cname == 'onedark'
            " highlight Comment guifg=SlateGray4 ctermfg=67
        elseif cname == 'professional'
            highlight ColorColumn guibg=BlanchedAlmond
        elseif cname == 'quantum'
            highlight CursorLine guibg=gray27
        elseif cname == 'solarized' || cname == 'desert'
            highlight ColorColumn guibg=DarkSlateGray
        endif
        
    " }}}
" }}}

" Keys {{{
    " Some useful keymappig links:
    " - https://raddevon.com/articles/what-to-do-when-a-vim-keymap-doesnt-work/

    let mapleader = "\<Space>"
    let g:mapleader = "\<Space>"

    :nnoremap <leader>ve :vsplit $MYVIMRC<cr>

    " Wrapped lines goes down/up to next row, rather than next line in file.
    noremap j gj
    noremap k gk

    " scroll up/down without moving the cursor
    noremap <c-k> 1<c-u>
    noremap <c-j> 1<c-d>

    " Some cool stuff I got from http://howivim.com/2015/steve-francia/ {{
    " Visual shifting (does not exit Visual mode)
    vnoremap < <gv
    vnoremap > >gv

    nnoremap < <l
    nnoremap > >l

    " Allow using the repeat operator with a visual selection (!)
    vnoremap . :normal .<CR>

    nnoremap Y y$
    " }}

    " Use the black hole register to paste without overwriting the unnamed
    " register.
    vnoremap p "_dP

    " Overwrite current character with one from line above. NOTE that this ONLY
    " works with "virtualedit" equals "all". To do this right, we'd probably need a
    " functiont that could save, set, restore vitualedit. And would (hopefully?) be
    " more efficient (as this is VERY slow).
    " nnoremap <c-k> kyljv"0pl
    " inoremap <c-k> <esc>lkyljv"0pli

    " Tab navigation.
    nnoremap <S-H> gT
    nnoremap <S-L> gt

    " Beginning / end of line.
    nnoremap <c-h> ^
    nnoremap <c-l> $

    " These become useful when using an auto-close plugin.
    inoremap <c-h> <c-o>h
    inoremap <c-l> <c-o>l

    "
    " Command mode mappings.
    " Note that these match cvim.
    "

    " forward/backward char
    cnoremap <c-l> <right>
    cnoremap <c-h> <left>

    " forward/backward word
    cnoremap <c-y> <s-left>
    cnoremap <c-o> <s-right>

    " begin/end of line
    " default begin: <c-b> 
    "   default end: <c-e> 

    " up/down line
    cnoremap <c-j> <down>
    cnoremap <c-k> <up>

    " delete char / word
    cnoremap <c-x> <del>
    " default word: <c-w>

    " Write buffers.
    nnoremap <leader>w :w!<cr>
    nnoremap <leader>W :wa!<cr>

    " Delete buffer.
    " nnoremap <c-q> :bdelete<cr>
    nnoremap <c-o> :bdelete<cr>

    "
    " I've been trying for ages to get a simple keystroke that will allow me to
    " bounce back and forth between two buffers. I've tried to leverage vim's
    " "alternate file", but that can get hosed up when buffers are simply
    " deleted rather than wiped out. And trying to ensure a buffer is wiped out
    " can be a pain in the ass.
    "
    " My next attempt was to use BufferGator's MRU capabilities. The problem
    " with that is that its MRU list is not actually in most recently _used_
    " order, but rather most recently _opened_. IOW, it has the concept of
    " opening the previous buffer, but after doing so, going to the previous
    " buffer again doesn't return us back to where we started - we have to go
    " to the next buffer to do that. Here's what I had for that: 
    " nnoremap <leader><leader> :call <SID>BuffergatorAltFile(<SID>GetBuffergatorAltFileDirection())<cr>
    " nnoremap <leader>, :call <SID>BuffergatorAltFile('prev')<cr> nnoremap
    " <leader>. :call <SID>BuffergatorAltFile('next')<cr>
    "
    " But... I'm fed up enough with this that I'm going bite the bullet and
    " write my own plugin to do this. It'll be a good learning experience and
    " I'll get what I want. This may be a useful resource:
    "
    " https://github.com/vim-scripts/bufmru.vim/blob/821869d8b6139536c1122902493de00c654b5a2a/plugin/bufmru.vim
    "
    " And of course there's this:
    "
    " http://learnvimscriptthehardway.stevelosh.com/
    "
    
    " Goto previous buffer.
    nnoremap <leader><leader> <C-^>

    " Ideally, used in split window with desired diff buffers open.
    nnoremap <leader>dt :windo diffthis<CR>
    nnoremap <leader>do :windo diffoff<CR>
    nnoremap <leader>du :diffupdate<CR>

    " Build with gradle.
    nnoremap <leader>gb :compiler gradlew<CR> :make compile<CR>
    nnoremap <leader>gt :compiler gradlew<CR> :make test<CR>

    "
    " <C-o> instead of <esc> to reduce side-effects. More here:
    "
    "   http://vim.wikia.com/wiki/Use_Ctrl-O_instead_of_Esc_in_insert_mode_mappings
    "

    nnoremap <C-\> :set cursorcolumn!<cr>
    imap <C-\> <C-o><C-\>

    " <tab> to move to matching paren, bracket, etc.
    nnoremap <tab> %
    vnoremap <tab> %

    " Toggle line numbers.
    nnoremap <C-n> :call CycleNumber()<cr>
    imap <C-n> <C-o><C-n>

    " Turn current highlight off.
    nnoremap <silent> <leader>/ :noh<cr>

    " Search for my section headers.
    nnoremap <leader>s /^.*-\{40,80}\n^.*\[.*\]\s*\_.\{-}-\{40,80}\s*$<cr>

    "
    " Plugin-related global key mappings (buffer local plugin mappings in
    " "Plugin Config" section below).
    "
    
    nnoremap <leader>e :Defx<cr>

    " vim-surround's default keys include 'ds'. I have lots of plugins with
    " buffer-local key mappings use 'd' (e.g. buffergator's delete buffer),
    " and I don't want the associated key delay.
    let g:surround_no_mappings = 1
    let g:surround_no_insert_mappings = 1

    nmap sd  <Plug>Dsurround
    nmap sc  <Plug>Csurround
    nmap sC  <Plug>CSurround
    nmap ss  <Plug>Ysurround
    nmap sS  <Plug>YSurround
    nmap sss <Plug>Yssurround
    nmap ssS <Plug>YSsurround
    xmap S   <Plug>VSurround
    xmap sg  <Plug>VgSurround
    
" }}}

" Autocommands {{{

    " gradle {{{
        autocmd BufNewFile,BufRead *.gradle setfiletype groovy
    " }}}
    
    " python {{{
        " python comment indents are all hosed up. This will fix it.
        " See: http://stackoverflow.com/questions/2360249
        autocmd BufRead,BufNewFile *.py inoremap # X<c-h>#<space>
    " }}}
    
    " shell scripts {{{
        autocmd FileType sh setlocal shiftwidth=2
        autocmd FileType sh setlocal softtabstop=2
    " }}}
    
    " ruby {{{
        autocmd FileType ruby setlocal shiftwidth=2 
        autocmd FileType ruby setlocal softtabstop=2 
    " }}}

    " terrafrom {{{
        autocmd FileType terraform setlocal shiftwidth=2 
        autocmd FileType terraform setlocal softtabstop=2 
        autocmd FileType terraform setlocal commentstring=#\ %s
    " }}}
    
    " vimdiff {{{
        augroup VimDiff
            autocmd!
            autocmd VimEnter,FileWritePre * 
                \   nnoremap <expr> <C-j> &diff ? ']c' : '<Nop>' 
                \ | nnoremap <expr> <C-k> &diff ? '[c' : '<Nop>'
                \ | nnoremap <expr> <leader>dg &diff ? ':diffget<CR>' : '<Nop>'
                \ | nnoremap <expr> <leader>dp &diff ? ':diffput<CR>' : '<Nop>'
                \ | if &diff | set diffopt=filler,context=10000 | endif
        augroup END
    " }}}

    " yaml {{{
        autocmd FileType yaml setlocal shiftwidth=2 
        autocmd FileType yaml setlocal softtabstop=2 
        autocmd FileType yaml setlocal commentstring=#\ %s
    " }}}

    " .vimrc {{{
        " reread .vimrc on save
        autocmd! BufWritePost .vimrc source % 

        " prevent our .vimrc modeline from closing all our folds on save
        autocmd! BufWritePre .vimrc setlocal nomodeline
    " }}}

    " {{{ text
        autocmd BufRead,BufNewFile *.txt setlocal textwidth=72
        autocmd BufRead,BufNewFile *.txt setlocal formatoptions=tq

        " Turn off handling of '-' as a bullet (sort of).
        autocmd BufRead,BufNewFile *.txt setlocal comments-=fb:-
    "  }}}

    " Debugging {{{
        " autocmd BufCreate   * echom('========== BufCreate:'   . expand('%'))
        " autocmd BufEnter    * echom('========== BufEnter:'    . expand('%'))
        " autocmd BufHidden   * echom('========== BufHidden:'   . expand('%'))
        " autocmd BufLeave    * echom('========== BufLeave:'    . expand('%'))
        " autocmd BufNew      * echom('========== BufNew:'      . expand('%'))
        " autocmd BufRead     * echom('========== BufRead:'     . expand('%'))
        " autocmd BufWinEnter * echom('========== BufWinEnter:' . expand('%'))
        " autocmd BufWipeout  * echom('========== BufWipeout:'  . expand('%')) 
        " autocmd FileType    * echom('========== FileType:'    . expand('%')) 
        " autocmd VimEnter    * echom('========== VimEnter:'    . expand('%'))
    " }}}
"}}}

" Plugin Config {{{

    " Airline {{{
        if !exists('g:airline_theme')
            let g:airline_theme = 'molokai'
        endif

        let g:airline_powerline_fonts = 1
        if !exists('g:airline_symbols')
            let g:airline_symbols = {}
        endif
        let g:airline_symbols.space = "\ua0"
    " }}}
                                     
    " Buffergator {{{
        let g:buffergator_autoexpand_on_split = 0
        let g:buffergator_mru_cycle_local_to_window = 1
        let g:buffergator_mru_cycle_loop = 0
        let g:buffergator_sort_regime = "filepath"
        let g:buffergator_split_size = 15
        let g:buffergator_viewport_split_policy = "T"            

        " Commenting this out for now because BufferGator's MRU is not really
        " an MRU.
        "
        " let s:buffergator_alt_file_direction = 'prev'
        "                                          
        " function! s:GetBuffergatorAltFileDirection() 
        "     return s:buffergator_alt_file_direction
        " endfunction
        "                                          
        " function! s:BuffergatorAltFile(direction) 
        "     if a:direction ==# 'prev'
        "         execute 'BuffergatorMruCyclePrev'
        "         let s:buffergator_alt_file_direction = 'next'
        "     elseif a:direction ==# 'next'
        "         execute 'BuffergatorMruCycleNext'
        "         let s:buffergator_alt_file_direction = 'prev'
        "     endif
        " endfunction
    " }}}
   
    " Defx {{{
        autocmd FileType defx call s:DefxSettings()
        
        function! s:DefxSettings() 

            " Define mappings
            nnoremap <silent><buffer><expr> <CR> defx#do_action('open')
            nnoremap <silent><buffer><expr> ~    defx#do_action('cd')
            nnoremap <silent><buffer><expr> -    defx#do_action('cd', ['..'])
            nnoremap <silent><buffer><expr> u    defx#do_action('cd', ['..'])
            nnoremap <silent><buffer><expr> t    defx#do_action('open_or_close_tree')
            nnoremap <silent><buffer><expr> T    defx#do_action('open_tree_recursive')
            nnoremap <silent><buffer><expr> .    defx#do_action('toggle_ignored_files')
            nnoremap <silent><buffer><expr> yy   defx#do_action('yank_path')
            nnoremap <silent><buffer><expr> q    defx#do_action('quit')
            nnoremap <silent><buffer><expr> K    defx#do_action('new_directory')
            nnoremap <silent><buffer><expr> N    defx#do_action('new_file')
            nnoremap <silent><buffer><expr> M    defx#do_action('new_multiple_files')
            nnoremap <silent><buffer><expr> D    defx#do_action('remove')
            nnoremap <silent><buffer><expr> s    defx#do_action('toggle_select')
            vnoremap <silent><buffer><expr> s    defx#do_action('toggle_select_visual')
            

            " For some reason, mapping this key can cause all kinds of grief.
            " Unmap it and run '$ vim <dir>' in a terminal to see it.
            " nnoremap <silent><buffer><expr> <esc> defx#do_action('quit')
        endfunction

        "
        " The following is all about implementing some sort of sane buffer
        " handling for for file browsing. That is:
        "
        " - Fully replace netrw with defx.
        " - Proper alternate buffer handling when using defx (i.e. the defx
        "   buffer _never_ becomes the alternate file).
        "

        autocmd FileType defx setlocal bufhidden=wipe 

        augroup defx_buffers
            autocmd!
            autocmd BufEnter,VimEnter,BufNew,BufWinEnter,BufRead,BufCreate
                \ * call s:explore(expand('<amatch>'))
        augroup END

        let s:alt_buf = ''

        autocmd BufLeave * 
            \  if &filetype ==# 'defx' && s:alt_buf != '' 
            \|     if bufnr(s:alt_buf) != -1
            \|         let @# = bufnr(s:alt_buf) 
            \|     endif
            \|     let s:alt_buf = ''
            \| elseif &filetype != 'defx'
            \|     let s:alt_buf = expand('%')
            \| endif

        function s:explore(path)
            " echom('explore:a:path: '    . a:path)
            " echom('explore:bufname: '   . bufname('%'))
            " echom('explore:bufnr: '     . bufnr('%'))
            " echom('explore:bufhidden: ' . &bufhidden)
            " echom('explore:abuf: '      . expand('<abuf>'))
            " echom('explore:filetype: '  . &filetype)
            " echom('explore:lines: '     . line('$'))

            if a:path == '' || &filetype ==# 'defx' 
                return
            endif

            " Handle ':edit ~'.
            let path = a:path
            if fnamemodify(path, ':t') ==# '~'
                let path = expand('~')
            endif

            if isdirectory(path) 

                " Disable netrw.
                augroup FileExplorer
                    autocmd!
                augroup END

                " The current buffer was opened with a directory path. We need
                " to wipe it out and replace it with a defx buffer on that same
                " path.
                bwipeout!

                call defx#util#call_defx('Defx', path)
            endif
        endfunction
    " }}}
    
    " Denite {{{
        if executable('ag')
            call denite#custom#var('file/rec', 'command', 
                \ ['ag', '--follow', '--nocolor', '--nogroup', '-g', '']) 

            call denite#custom#var('grep', 'command', ['ag'])
            call denite#custom#var('grep', 'default_opts', ['-i', '--vimgrep'])
            call denite#custom#var('grep', 'final_opts', [])
            call denite#custom#var('grep', 'pattern_opt', [])
            call denite#custom#var('grep', 'recursive_opts', [])
            call denite#custom#var('grep', 'separator', ['--'])

        elseif executable('rg')
            call denite#custom#var('file/rec', 'command', 
                \ ['rg', '--files', '--glob', '!.git'])

            call denite#custom#var('grep', 'command', ['rg'])
            call denite#custom#var('grep', 'command', ['rg', '--threads', '1'])
            call denite#custom#var('grep', 'default_opts', ['--vimgrep', '--no-heading'])
            call denite#custom#var('grep', 'final_opts', [])
            call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
            call denite#custom#var('grep', 'recursive_opts', [])
            call denite#custom#var('grep', 'separator', ['--'])
        endif

        call denite#custom#option('_', 'prompt', '>')
        call denite#custom#option('_', 'direction', 'dynamictop')
        call denite#custom#option('_', 'filter_split_direction', 'belowright')
        call denite#custom#option('_', 'vertical_preview', 'true')

        " Not sure this is best for all colorschemes (is for quantum).
        call denite#custom#option('_', 'highlight_matched_char', 'Special')

        call denite#custom#source('file/rec', 'matchers', ['matcher/regexp'])
        call denite#custom#source('grep', 'matchers', ['matcher/regexp'])
        call denite#custom#source('grep', 'converters', ['converter/abbr_word'])

        autocmd FileType denite call s:denite_my_settings()

        function! s:denite_my_settings() abort
            nnoremap <silent><buffer><expr> <CR> denite#do_map('do_action')
            nnoremap <silent><buffer><expr> d    denite#do_map('do_action', 'delete')
            nnoremap <silent><buffer><expr> i    denite#do_map('open_filter_buffer')
            nnoremap <silent><buffer><expr> p    denite#do_map('do_action', 'preview')

            nnoremap <silent><buffer><expr> <esc> denite#do_map('quit')
            nnoremap <silent><buffer><expr> q     denite#do_map('quit')
        endfunction

        autocmd FileType denite-filter call s:denite_filter_my_settings()

        function! s:denite_filter_my_settings() abort
            " Quit filter window.
            imap <silent><buffer> <esc> <Plug>(denite_filter_quit)

            " Quit filter window and denite.
	        imap <silent><buffer> <C-o> <Plug>(denite_filter_quit)q

            " Move cursor while in insert mode.
            inoremap <silent><buffer> <C-j>
                        \ <Esc><C-w>p:call cursor(line('.')+1,0)<CR><C-w>pA
            inoremap <silent><buffer> <C-k>
                        \ <Esc><C-w>p:call cursor(line('.')-1,0)<CR><C-w>pA
        endfunction

        nnoremap <leader>f :<C-u>Denite file -start-filter<cr>
        nnoremap <leader>r :<C-u>Denite file/rec -start-filter<cr>
        nnoremap <leader>R :<C-u>Denite grep -start-filter<cr>

        nnoremap <leader>p :<C-u>DeniteProjectDir file/rec -start-filter<cr>
        nnoremap <leader>P :<C-u>DeniteProjectDir grep -start-filter<cr>
    " }}}

    " Miscellaneous {{{
        let g:rainbow_active = 1
        let g:vim_yaml_helper#auto_display_path = 1
    " }}}

    " SuperTab {{{
        " <c-space> is gobally mapped to :buffer#, but there seems
        " to be no conflict here.
        let g:SuperTabMappingForward = '<c-space>'
        let g:SuperTabMappingBackward = '<s-c-space>'

        let g:SuperTabDefaultCompletionType = "context"
        let g:SuperTabContextDefaultCompletionType = "<c-n>"
    " }}}
    
    " VimWiki {{{
        silent! nunmap <leader>ww
        silent! nunmap <leader>wi
        silent! nunmap <leader>ws
        silent! nunmap <leader>wt
        silent! nunmap <leader>w<leader>t
        silent! nunmap <leader>w<leader>w
        silent! nunmap <leader>w<leader>i

        nmap <leader>vw <Plug>VimwikiIndex
        nmap <leader>vi <Plug>VimwikiTabIndex
        nmap <leader>vs <Plug>VimwikiUISelect
        nmap <leader>vr <Plug>VimwikiRenameLink
        nmap <leader>vdw <Plug>VimwikiDiaryIndex
        nmap <leader>vdt <Plug>VimwikiTabMakeDiaryNote
        nmap <leader>vdn <Plug>VimwikiMakeDiaryNote
        nmap <leader>vdg <Plug>VimwikiDiaryGenerateLinks

        autocmd FileType vimwiki setlocal textwidth=78
    " }}}
" }}}

" Functions {{{

    " Dump output of an ex command to a new buffer in a new tab. Primarily
    " useful for searching ex command output.  
    " Example: :TabMessage map
    " 
    function! TabMessage(cmd)
      redir => message
      silent execute a:cmd
      redir END
      if empty(message)
        echoerr "no output"
      else
        " use "new" instead of "tabnew" below if you prefer split windows instead of tabs
        tabnew
        setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted nomodified
        silent put=message
      endif
    endfunction
    command! -nargs=+ -complete=command TabMessage call TabMessage(<q-args>)

    " Wanted to have <c-n> run invnumber and <c-r> run invrelativenumber so I
    " could toggle these independently, but <c-r> is redo and I didn't want to
    " mess with that. With this function I can just cycle through using a
    " single key.
    "
    function! CycleNumber() 
        if ! &number && ! &relativenumber
            set number
        elseif &number && ! &relativenumber
            set relativenumber
        else
            set nonumber
            set norelativenumber
        endif
    endfunction


    function! FormatCss()

        " TODO: Make sure we're in css buffer?

        "
        " Decontstruct the file to a consistent format from which
        " we can reliably reconstruct it.
        "

        silent %s///g                       " Just in case, delete any control-M's.
        silent %s/\s*$//g                     " Remove trailing whitespace on all lines.
        silent %s/\s\+/ /g                    " Replace multiple whitespace with single space.
        silent g/^\s*$/d                      " Delete all blank lines.
        silent %s/\n//g                       " Remove all carriage returns.

        "
        " Reformat the deconstructed file.
        "
        
        silent %s/\*\//*\/\r\r/g              " Two newlines after comment lines.
        silent %s/}/}\r\r/g                   " Two newlines after }.
        silent %s/{/{\r/g                     " Newline after {.
        silent %s/;/;\r/g                     " Newline after ;.
        silent %s/^\(\s*\S\+.*\)}$/\1\r}/g    " Newline before ).

        " TODO: There's a potential issue with sorting attributes in
        " that the original css could have multiple attributes, with
        " the last one not being terminated with a ';'. In this case,
        " sorting could move that attribute to the middle of the list,
        " which, without the ';', would be invalid html. Therefore,
        " we'll simply return here until we account for this.

        return

        "
        " Sort attributes.
        "

        " Start at top of file.
        normal gg

        while search("{$", "W")
            +1
            let first = line(".")

            /}
            -1
            let last = line(".")

            execute first . "," . last . "sort"
        endwhile

        " Indent file.
        normal gg=G

    endfunction

    nmap <silent> _c :call FormatCss()<CR>

" }}}

" TODO / etc {{{
"
"   - Snippets
"
"   - Tags
"
"   - Copy character from line above/below?.
"
"   - I have some diff mode stuff configured here (see the VimDiff and windo
"   keymappings above). It would be nice if we did a 'diffoff' while in a Vim
"   Fugitive diff, that we delete the git index buffer.
"
"   - Some interesting things I see in Nate Neff's vim github project:
"
"     <Space>    Show recent buffers at bottom of screen.
"                Use 'f' and 'b' to move back & forth between them.
"                Thanks to bufmru plugin author!
"
"     # NERD Commenter
"     
"      <leader>ci      Comment / Uncomment line(s)
"      <leader>cu      UN-comment line(s)
"      <leader>cl      Comment lines
"     
" }}}

" I (or preceeding blank) am only here to ensure last fold doesn't misbehave.
