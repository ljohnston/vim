" Modeline & Notes {{{
" vim: set sw=4 ts=4 sts=4 et tw=79 foldlevel=0 foldmethod=marker foldmarker={{{,}}}:
"
" My .vimrc - Always needs lots of work. See the TODO section for things on
" the list.
"
"   Development Notes {{{
"     Debugging: Can insert 'echom "<msg>"' to show mesages in the cmd window.
"     These typically will disappear when output from .vimrc but can be
"     displayed with ':messages'.
"
"     An interesting vim debugging link:
"         https://codeinthehole.com/tips/debugging-vim-by-example/
"
"   }}}
" }}}

" Environment {{{
    if &compatible
      set nocompatible
    endif

    silent function! OSX()
        return has('macunix')
    endfunction

    silent function! LINUX()
        return has('unix') && !has('macunix') && !has('win32unix')
    endfunction

    silent function! WINDOWS()
        return  (has('win32') || has('win64'))
    endfunction

    if WINDOWS()
        set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
    endif

    "
    " Create a '~/.vim/python' symlink to python home to turn this on...
    " python -> ~/.asdf/installs/python/3.7.3-framework-vim/Python.framework/Versions/3.7
    "
    " Install neovim in python env:
    "   $ pip install neovim
    "
    if isdirectory($HOME . '/.vim/python') && !exists('s:python_initialized')
       set pyxversion=3

       let $PATH = $HOME . '/.vim/python/bin:' . $PATH

       if !has('nvim')
           set pythonthreehome=/Users/lance.johnston/.vim/python
           set pythonthreedll=/Users/lance.johnston/.vim/python/lib/libpython3.7.dylib
       endif

       let s:python_initialized = 1
    endif
" }}}

" Install Plugins {{{
    call plug#begin('~/.vim/plugged')

        Plug 'Shougo/deoplete.nvim'

        " if !has('nvim')
        "     Plug 'roxma/nvim-yarp'
        "     Plug 'roxma/vim-hug-neovim-rpc'
        " endif

        " Plug 'vim-airline/vim-airline'
        " Plug 'vim-airline/vim-airline-themes'
        Plug 'flazz/vim-colorschemes'
        Plug 'itchyny/lightline.vim'

        " Plug 'Shougo/denite.nvim', { 'tag': '3.2', 'do': ':UpdateRemotePlugins' }
        "Plug 'Shougo/defx.nvim', { 'tag': '1.0' }
        " Plug 'Shougo/defx.nvim', { 'do': ':UpdateRemotePlugins' }
        
        Plug 'preservim/nerdtree'

        Plug 'tpope/vim-abolish'
        Plug 'tpope/vim-fugitive'
        Plug 'tpope/vim-surround'
        
        Plug 'jeetsukumaran/vim-buffergator'

        Plug 'rodjek/vim-puppet'
        Plug 'markcornick/vim-terraform'
        Plug 'lmeijvogel/vim-yaml-helper'
        
        Plug 'luochen1990/rainbow'
        Plug 'mtth/scratch.vim'
        " Plug 'ervandew/supertab'
        Plug 'ajh17/VimCompletesMe'
        Plug 'scrooloose/syntastic'
        Plug 'godlygeek/tabular'
        Plug 'tomtom/tcomment_vim'
        
        Plug 'jiangmiao/auto-pairs'
        
        Plug 'vim-scripts/groovyindent-unix'
        
        Plug 'vimwiki/vimwiki'
    call plug#end()

    if exists("g:plugin_install") && g:plugin_install == 1 
        finish
    endif
" }}}

" Altbuf Plugin {{{

    " TODO (for a real plugin):
    " - check compatible
    " - global configuration options, defaults
    
    " TODO (issues):

    " autocmd event notes
    " - We get a bdelete on a bwipeout
    " - Some plugins seem to do weird things with the events. For example, netrw
    "   fires a BufEnter event before the buffer has name and then files two (yes,
    "   two) BufDelete events. It isn't until the second BufDelete that the
    "   buffer's filetype is correctly set to netrw. On the BufEnter, buflisted=1.
    
    " command! -nargs=0 AltbufPrevious :call AltbufPrevious()
    "
    " augroup altbuf
    "     autocmd!
    "     autocmd BufEnter * call s:AltbufDebug('BufEnter') | call s:AltbufEnter()
    "     autocmd BufDelete * call s:AltbufDebug('BufDelete') | call s:AltbufDelete()
    " augroup END
    "
    "
    " function! s:AltbufDebugMsg(msg)
    "     " unsilent echom(a:msg)
    " endfunction
    "
    "
    " function! s:AltbufDebug(event)
    "     call s:AltbufDebugMsg('--------------------')
    "     call s:AltbufDebugMsg(a:event . ':<abuf>=' . expand('<abuf>'))
    "     call s:AltbufDebugMsg(a:event . ':filetype=' . &filetype)
    "     call s:AltbufDebugMsg(a:event . ':buflisted=' . &buflisted)
    "     call s:AltbufDebugMsg(a:event . ':bufname(%)=' . bufname('%'))
    "     call s:AltbufDebugMsg(a:event . ':winnr())=' . winnr())
    "     call s:AltbufDebugMsg('--------------------')
    " endfunction
    "
    " " I _think_ we can use this to identify a window-specific bufList...
    " " getwininfo(win_getid())[0]['bufnr']
    " "
    " " We can use this to check if a window ID is still open
    " " range(1,winnr('$'))
    " " win_getid(<win number from above>)
    " "
    " " Here's what we want to do...
    " "
    " " - On bufenter get the window ID and buffer and manage a window-specific
    " "   buffer list just as we are now.
    " " - On bufenter get list of all existing window IDs and compare to the list
    " "   of window IDs we have bufferlists for. If any window are missing,
    " "   delete the dictionary entry for the window IDs that no longer exist.
    " " - On bufdelete, we need to remove the buffer from _all_ window buflists
    " "   where it exists.
    "
    " let s:winBufDict = {}
    " let s:bufWinDict = {}
    "
    " " TODO: Make these configurable plugin options.
    " let s:includeFiletypes = ['help']
    " let s:excludeFiletypes = ['netrw']
    "
    " " Ignore buffers with empty name (e.g. "[No Name]" buffers)
    " let s:excludeBufnames = ['\v^\s*$']
    "
    " function! s:AltbufEnter()
    "     call s:AltbufDebugMsg('altbufEnter:@%=' . @%)
    "     call s:AltbufDebugMsg('altbufEnter:@#=' . @#)
    "     call s:AltbufDebugMsg('altbufEnter:<abuf>=' . expand('<abuf>'))
    "     call s:AltbufDebugMsg('altbufEnter:win_getid()=' . win_getid())
    "     call s:AltbufDebugMsg("altbufEnter:getwininfo(win_getid())[0]['bufnr']=" . getwininfo(win_getid())[0]['bufnr'])
    "
    "     let l:winid = win_getid()
    "     let l:bufnr = bufnr('%')
    "
    "     if !has_key(s:winBufDict, l:winid)
    "         let s:winBufDict[l:winid] = []
    "     endif
    "
    "     if !has_key(s:bufWinDict, l:bufnr)
    "         let s:bufWinDict[l:bufnr] = []
    "     endif
    "
    "     let l:winBufList = get(s:winBufDict, l:winid)
    "     let l:bufWinList = get(s:bufWinDict, l:bufnr)
    "
    "     call s:EnsureListElement(l:bufWinList, l:winid)
    "     
    "     " Remove buffer from list if it exists, and put it on top.
    "     call s:RemoveListElement(l:winBufList, l:bufnr)
    "     call add(l:winBufList, l:bufnr)
    "     
    "     call s:AltbufDebugMsg('AltbufEnter:winBufList=' . join(l:winBufList))
    "     call s:AltbufDebugMsg('AltbufEnter:bufWinList=' . join(l:bufWinList))
    " endfunction
    "
    "
    " function! s:AltbufDelete()
    "     call s:AltbufDebugMsg('altbufDelete:@%=' . @%)
    "     call s:AltbufDebugMsg('altbufDelete:@#=' . @#)
    "     call s:AltbufDebugMsg('altbufDelete:<abuf>=' . expand('<abuf>'))
    "     call s:AltbufDebugMsg('altbufDelete:win_getid()=' . win_getid())
    "     call s:AltbufDebugMsg("altbufDelete:getwininfo(win_getid())[0]['bufnr']=" . getwininfo(win_getid())[0]['bufnr'])
    "
    "     let l:bufnr = bufnr('%')
    "     let l:winList = s:bufWinDict[l:bufnr]
    "     
    "     for winid in l:winList
    "         let l:bufList = s:winBufDict[winid]
    "         call s:RemoveListElement(l:bufList, l:bufnr)
    "     endfor
    "     
    " endfunction
    "
    "
    " function! PruneWinDict()
    "
    "     let l:altbufWinList = keys(s:winBufDict)
    "     let l:vimWinList = map(range(1, winnr('$')), 'win_getid(v:val)')
    "
    "     for winid in l:altbufWinList
    "
    "         " Could do this with a filter.
    "         if index(l:vimWinList, winid) == -1
    "             unlet s:winBufDict[winid]
    "         endif
    "
    "     endfor
    "
    " endfunction
    "
    "
    " function! s:EnsureListElement(list, element)
    "
    "     if index(a:list, a:element) == -1
    "         call add(a:list, a:element)
    "     endif
    "
    " endfunction
    "
    "
    " function! s:RemoveListElement(list, element)
    "     let l:idx = index(a:list, a:element)
    "
    "     if l:idx >= 0
    "         call remove(a:list, l:idx)
    "     endif
    "
    " endfunction
    "
    "
    " function s:IsExcludedBufname(bufname)
    "
    "     for pattern in s:excludeBufnames
    "         if a:bufname =~ pattern
    "             return 1
    "         endif
    "     endfor
    "
    "     return 0
    " endfunction
    "
    " function! s:IsExcludedBuf(bufnr)
    "
    "     let l:filetype = getbufvar(a:bufnr, '&filetype')
    "
    "     " Excludes take precedence.
    "     if index(s:excludeFiletypes, l:filetype) >= 0
    "         return 1
    "     endif
    "
    "     if s:IsExcludedBufname(bufname(a:bufnr)) 
    "         return 1
    "     endif 
    "
    "     " Incude filetypes take precedence over unlisted bufs.
    "     if index(s:includeFiletypes, l:filetype) >= 0
    "         return 0
    "     endif
    "
    "     if !buflisted(a:bufnr)
    "         return 1
    "     endif
    "
    "     return 0
    "     
    " endfunction
    "
    " function! AltbufList()
    "     echo(s:winBufDict)
    " endfunction
    "
    " function! AltbufPrevious()
    "
    "     let l:winBufList = get(s:winBufDict, win_getid())
    "     let l:bufListLen = len(l:winBufList)
    "
    "     " Why are we doing this???
    "     " if l:bufListLen > 0 && (bufnr('%') != l:winBufList[-1])
    "     "     execute 'buffer' . l:winBufList[-1]
    "     " endif
    "
    "     if l:bufListLen < 2
    "         return
    "     endif
    "
    "     while l:bufListLen >= 2 && s:IsExcludedBuf(l:winBufList[l:bufListLen - 2])
    "         call remove(l:winBufList, l:bufListLen - 2)
    "         let l:bufListLen -= 1
    "     endwhile
    "
    "     execute 'buffer' . l:winBufList[l:bufListLen - 2]
    " endfunction

" }}}

" General {{{
    filetype plugin indent on
    syntax enable

    scriptencoding utf-8
    set encoding=utf-8

    set fileformats=unix 
    set history=100
    set ttyfast                             

    set nofileignorecase                    "case-sensitive file completion

    set ruler                               "show cursor position

    set scrolloff=3                         "context lines when scrolling
    set sidescrolloff=5                     "context columns when scrolling

    set laststatus=2                        "always show status line
    set showmode                            "display mode at bottom of screen
    set showcmd                             "show commands at bottom of screen

    set colorcolumn=81                      "make 80 columns obvious

    augroup CursorLine
        autocmd!
        autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline
        " autocmd WinLeave * 
            \  if &filetype !~ '^\(denite\|foo\)$' 
            \|     setlocal nocursorline
            \| endif
    augroup END

    set nostartofline                       "try to leave cursor in same column
    set virtualedit=all                     "allow cursor where no actual characters exist

    set backspace=indent,eol,start          "a better backspace

    set autoread                            "detect external file changes
    set hidden                              "change buffers without saving

    set showmatch                           "show matching character pair

    "set wildmenu                            "enhanced autocomplete
    "set wildmode=longest,list,full          "autocomplete behavior
    set wildmenu                            "enhanced autocomplete
    set wildmode=longest,full               "autocomplete behavior

    set ignorecase                          "ignore case in search, regex
    set smartcase                           "only ignore case if pattern is all lower

    set hlsearch                            "highlight search results
    set incsearch                           "search incremntally

    set shortmess+=filmnrxoOtT              "abbreviate messages (avoids 'hit enter')
    set cmdheight=1                         "command line rows

    set autoindent                          "indent at same level as previous line
    set smartindent                         "add indent for code blocks

    set expandtab                           "tabs as spaces
    set shiftwidth=4
    set softtabstop=4

    autocmd BufEnter * silent! lcd %:p:h    "cwd tracks current file

    " Silence the bell.
    set noerrorbells visualbell t_vb=
    autocmd GUIEnter * set visualbell t_vb=

    if has('clipboard')
        if has('unnamedplus')  
            " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        else         
            " On mac and Windows, use * register for copy-paste
            set clipboard=unnamed
        endif
    endif

    " Directories
    set backupdir=~/.vim/.backup//
    set directory=~/.vim/.swp//
    set undodir=~/.vim/.undo//
    set viewdir=~/.vim/.view

    " Strip trailing whitespace from these files.
    augroup whitespace
        autocmd!
        autocmd FileType groovy,java,python,puppet,ruby,terraform 
            \ autocmd BufWritePre <buffer> %s/\s\+$//e
    augroup END
" }}}

" UI {{{

    " GUI {{{

        " Note that gui commands that have any meaning with regard to
        " 'gui_running' include only 'guicursor', 'guifont', 'guipty', and
        " 'guioptions'. Note also that gui apps for neovim do not have
        " 'gui_running', nor do they support any of those gui commands. For the
        " OS X vimR at least, the font is set through normal OS X app
        " preferences.
        if has("gui_running")

           " 
           " For a good resource regarding how to pick and set a font, see:
           "
           "   http://www.scholarslab.org/grad-student-research/vim-gui-font-magic/
           "

           if OSX()
               if !has('gui_vimr')
                   set guifont=Sauce\ Code\ Powerline:h18
                   set columns=160
                   set lines=40
               endif
           elseif LINUX()
               set guifont=Source\ Code\ Pro\ for\ Powerline\ Medium\ 10
               set columns=120
               set lines=52
           else
               set guifont="Courier 10 Pitch":h10
               set columns=120
               set lines=64
           endif

           set guioptions-=T           " turn off the toolbar
           set guioptions-=l           " no scrollbars on the left
           set guioptions-=L           " no scrollbars on the left
           set guioptions-=r           " no scrollbars on the right
           set guioptions-=R           " no scrollbars on the right

           " turn off cursor blinking
           set guicursor+=a:blinkon0
        endif
    " }}}

    " {{{ colorscheme 
        " set background=light

        " colorscheme onedark
        " colorscheme professional
        " colorscheme molokai
        " colorscheme solarized
        " colorscheme desert
        " colorscheme neodark
        colorscheme quantum
        
        "
        " I'm not interested in creating my own versions of various color
        " schemes. I do, however, want to be able to tweak the ones I use if
        " necessary, so we'll do that here.
        "
        " TODO: Is there a better way to achieve the tweaks we want? Answer:
        " Yes, see https://github.com/vim-scripts/AfterColors.vim
        " 

        "
        " Got the following colorscheme stuff from:
        "
        " https://github.com/megaannum/colorschemer/blob/master/autoload/colorschemer/viewer.vim
        "

        let s:colorsname = ""

        function! s:GetColorSchemeName()
          if exists("g:colors_name")
            return g:colors_name
          else
            if exists("s:colorsname")
              unlet s:colorsname
            endif

            execute "redir => s:colorsname"
            silent execute "colorscheme"
            execute "redir END"
            let s:colorsname = s:colorsname[1:]
            return s:colorsname
          endif
        endfunction
        
        let cname = s:GetColorSchemeName()
        
        if cname == 'molokai'
            " Better cursor line colors.
            highlight CursorLine guibg=Gray27 ctermbg=238
            highlight CursorColumn guibg=Gray27 ctermbg=238
        
            " Default column color (i.e. column 80 indicator) sucks (it's red!).
            " highlight ColorColumn guibg=DarkSlateGray
        
            " Default comment color too dark.
            highlight Comment guifg=SkyBlue3 ctermfg=67
        
            " Default visual selection needs more contrast.
            highlight Visual guifg=Gray30 guibg=NavajoWhite
            " highlight Visual guibg=gray30
        elseif cname == 'neodark'
            highlight Normal guibg=gray18
        elseif cname == 'onedark'
            " highlight Comment guifg=SlateGray4 ctermfg=67
        elseif cname == 'professional'
            highlight ColorColumn guibg=BlanchedAlmond
        elseif cname == 'quantum'
            highlight CursorLine guibg=gray27 ctermbg=242
            highlight Folded guifg=#658494 ctermfg=9

            " A total hack for the time being for VimR.
            if has('nvim')
                highlight Search guibg=BlanchedAlmond guifg=NONE
            endif
        elseif cname == 'solarized' || cname == 'desert'
            highlight ColorColumn guibg=DarkSlateGray
        endif
        
    " }}}
" }}}

" Keys {{{
    " Some useful keymappig links:
    " - https://raddevon.com/articles/what-to-do-when-a-vim-keymap-doesnt-work/

    let mapleader = "\<Space>"
    let g:mapleader = "\<Space>"

    :nnoremap <leader>ve :vsplit ~/.vimrc<cr>

    noremap <leader>gs :Gstatus<cr>
    noremap <leader>gb :Gblame<cr>
    noremap <leader>gl :Glog<cr>

    noremap gyy :YamlGetFullPath<cr>
    noremap gyp :YamlGoToParent<cr>

    " Wrapped lines goes down/up to next row, rather than next line in file.
    noremap j gj
    noremap k gk

    " scroll up/down without moving the cursor
    noremap <c-k> 1<c-u>
    noremap <c-j> 1<c-d>

    " Some cool stuff I got from http://howivim.com/2015/steve-francia/ {{
    " Visual shifting (does not exit Visual mode)
    vnoremap < <gv
    vnoremap > >gv

    nnoremap < <l
    nnoremap > >l

    " Allow using the repeat operator with a visual selection (!)
    vnoremap . :normal .<CR>

    nnoremap Y y$
    " }}

    " Use the black hole register to paste without overwriting the unnamed
    " register.
    vnoremap p "_dP

    " Overwrite current character with one from line above. NOTE that this ONLY
    " works with "virtualedit" equals "all". To do this right, we'd probably need a
    " functiont that could save, set, restore vitualedit. And would (hopefully?) be
    " more efficient (as this is VERY slow).
    " nnoremap <c-k> kyljv"0pl
    " inoremap <c-k> <esc>lkyljv"0pli

    " Tab navigation.
    nnoremap <S-H> gT
    nnoremap <S-L> gt

    " Beginning / end of line.
    nnoremap <c-h> ^
    nnoremap <c-l> $

    " These become useful when using an auto-close plugin.
    inoremap <c-h> <c-o>h
    inoremap <c-l> <c-o>l

    "
    " Command mode mappings.
    " Note that these match cvim.
    "

    " forward/backward char
    cnoremap <c-l> <right>
    cnoremap <c-h> <left>

    " forward/backward word
    cnoremap <c-y> <s-left>
    cnoremap <c-o> <s-right>

    " begin/end of line
    " default begin: <c-b> 
    "   default end: <c-e> 

    " up/down line
    cnoremap <c-j> <down>
    cnoremap <c-k> <up>

    " delete char / word
    cnoremap <c-x> <del>
    " default word: <c-w>

    " Write buffers.
    nnoremap <leader>w :w!<cr>
    nnoremap <leader>W :wa!<cr>

    " Delete buffer.
    " nnoremap <c-q> :bdelete<cr>
    nnoremap <c-o> :bdelete<cr>

    "
    " I've been trying for ages to get a simple keystroke that will allow me to
    " bounce back and forth between two buffers. I've tried to leverage vim's
    " "alternate file", but that can get hosed up when buffers are simply
    " deleted rather than wiped out. And trying to ensure a buffer is wiped out
    " can be a pain in the ass.
    "
    " My next attempt was to use BufferGator's MRU capabilities. The problem
    " with that is that its MRU list is not actually in most recently _used_
    " order, but rather most recently _opened_. IOW, it has the concept of
    " opening the previous buffer, but after doing so, going to the previous
    " buffer again doesn't return us back to where we started - we have to go
    " to the next buffer to do that. Here's what I had for that: 
    " nnoremap <leader><leader> :call <SID>BuffergatorAltFile(<SID>GetBuffergatorAltFileDirection())<cr>
    " nnoremap <leader>, :call <SID>BuffergatorAltFile('prev')<cr> nnoremap
    " <leader>. :call <SID>BuffergatorAltFile('next')<cr>
    "
    " But... I'm fed up enough with this that I'm going bite the bullet and
    " write my own plugin to do this. It'll be a good learning experience and
    " I'll get what I want. This may be a useful resource:
    "
    " https://github.com/vim-scripts/bufmru.vim/blob/821869d8b6139536c1122902493de00c654b5a2a/plugin/bufmru.vim
    "
    " And of course there's this:
    "
    " http://learnvimscriptthehardway.stevelosh.com/
    "
    
    " Goto previous buffer.
    " nnoremap <leader><leader> <C-^>
    nnoremap <silent> <leader><leader> :AltbufPrevious<cr>

    " Ideally, used in split window with desired diff buffers open.
    nnoremap <leader>dt :windo diffthis<CR>
    nnoremap <leader>do :windo diffoff<CR>
    nnoremap <leader>du :diffupdate<CR>

    " Build with gradle.
    " nnoremap <leader>gb :compiler gradlew<CR> :make compile<CR>
    " nnoremap <leader>gt :compiler gradlew<CR> :make test<CR>

    "
    " <C-o> instead of <esc> to reduce side-effects. More here:
    "
    "   http://vim.wikia.com/wiki/Use_Ctrl-O_instead_of_Esc_in_insert_mode_mappings
    "

    nnoremap <C-\> :set cursorcolumn!<cr>
    imap <C-\> <C-o><C-\>

    " <tab> to move to matching paren, bracket, etc.
    nnoremap <tab> %
    vnoremap <tab> %

    " Toggle line numbers.
    nnoremap <C-n> :call CycleNumber()<cr>
    imap <C-n> <C-o><C-n>

    " Turn current highlight off.
    nnoremap <silent> <leader>/ :noh<cr>

    " Search for my section headers.
    nnoremap <leader>s /^.*-\{40,80}\n^.*\[.*\]\s*\_.\{-}-\{40,80}\s*$<cr>

    "
    " Plugin-related global key mappings (buffer local plugin mappings in
    " "Plugin Config" section below).
    "
    
    " nnoremap <leader>e :Defx<cr>
    
    nnoremap <leader>e :execute 'edit' . getcwd()<CR>
    let NERDTreeHijackNetrw=1
    let NERDTreeMinimalUI=1
    let NERDTreeQuitOnOpen=1

    let g:NERDTreeMapOpenRecursively='T'
    let g:NERDTreeMapToggleHidden='.'

    let g:NERDTreeMapChangeRoot=''
    let g:NERDTreeMapChdir=''
    let g:NERDTreeMapCWD=''
    let g:NERDTreeMapDeleteBoomark=''
    let g:NERDTreeMapOpenInTab=''
    let g:NERDTreeMapOpenInTabSilent=''
    let g:NERDTreeMapPreview=''
    let g:NERDTreeMapRefreshRoot=''
    let g:NERDTreeMapToggleBookmarks=''
    let g:NERDTreeMapToggleFiles=''
    let g:NERDTreeMapToggleFilters=''
    let g:NERDTreeMapToggleZoom=''

    autocmd FileType nerdtree setlocal bufhidden=wipe

    " vim-surround's default keys include 'ds'. I have lots of plugins with
    " buffer-local key mappings that use 'd' (e.g. buffergator's delete
    " buffer), and I don't want the associated key delay, so changing all
    " surround keys to begin with 's'. <nowait> on the plugin's mapping (e.g.
    " buffergator) would solve the problem, but key mapping for plugins aren't
    " always customizable (again, buffergator).  Possible solution here: 
    "
    " https://github.com/tpope/vim-surround/issues/98#issuecomment-21426681 
    "

    let g:surround_no_mappings = 1
    let g:surround_no_insert_mappings = 1

    nmap sd  <Plug>Dsurround
    nmap sc  <Plug>Csurround
    nmap sC  <Plug>CSurround
    nmap ss  <Plug>Ysurround
    nmap sS  <Plug>YSurround
    nmap sss <Plug>Yssurround
    nmap ssS <Plug>YSsurround
    xmap S   <Plug>VSurround
    xmap sg  <Plug>VgSurround
    
" }}}

" Autocommands {{{

    " gradle {{{
        autocmd BufNewFile,BufRead *.gradle setfiletype groovy
    " }}}
    
    " python {{{
        " python comment indents are all hosed up. This will fix it.
        " See: http://stackoverflow.com/questions/2360249
        autocmd BufRead,BufNewFile *.py inoremap # X<c-h>#<space>
    " }}}
    
    " shell scripts {{{
        autocmd FileType sh setlocal shiftwidth=2
        autocmd FileType sh setlocal softtabstop=2
    " }}}
    
    " ruby {{{
        autocmd FileType ruby setlocal shiftwidth=2 
        autocmd FileType ruby setlocal softtabstop=2 
    " }}}

    " terrafrom {{{
        autocmd FileType terraform setlocal shiftwidth=2 
        autocmd FileType terraform setlocal softtabstop=2 
        autocmd FileType terraform setlocal commentstring=#\ %s
    " }}}
    
    " vimdiff {{{
        augroup VimDiff
            autocmd!
            autocmd VimEnter,FileWritePre * 
                \   nnoremap <expr> <C-j> &diff ? ']c' : '<Nop>' 
                \ | nnoremap <expr> <C-k> &diff ? '[c' : '<Nop>'
                \ | nnoremap <expr> <leader>dg &diff ? ':diffget<CR>' : '<Nop>'
                \ | nnoremap <expr> <leader>dp &diff ? ':diffput<CR>' : '<Nop>'
                \ | if &diff | set diffopt=filler,context=10000 | endif
        augroup END
    " }}}

    " yaml {{{
        autocmd FileType yaml setlocal shiftwidth=2 
        autocmd FileType yaml setlocal softtabstop=2 
        autocmd FileType yaml setlocal commentstring=#\ %s
    " }}}

    " .vimrc {{{
        " reread .vimrc on save
        " For some reason I don't understand, sourceing .vimrc causes lightline
        " to lose it's colors (it's just white on black), but only apparently
        " in normal mode. We'll hack our way around this for now with this...
        autocmd! BufWritePost .vimrc source % | :call lightline#enable()

        " prevent our .vimrc modeline from closing all our folds on save
        autocmd! BufWritePre .vimrc setlocal nomodeline
    " }}}

    " {{{ text
        autocmd BufRead,BufNewFile *.txt setlocal textwidth=72
        autocmd BufRead,BufNewFile *.txt setlocal formatoptions=tq

        " Turn off handling of '-' as a bullet (sort of).
        autocmd BufRead,BufNewFile *.txt setlocal comments-=fb:-
    "  }}}

    " Debugging {{{
    augroup vimrc_debug
        autocmd!
        " autocmd BufCreate   * unsilent echom('========== BufCreate:'   . expand('%'))
        " autocmd BufEnter    * unsilent echom('========== BufEnter:'    . expand('%'))
        " autocmd BufHidden   * unsilent echom('========== BufHidden:'   . expand('%'))
        " autocmd BufLeave    * unsilent echom('========== BufLeave:'    . expand('%'))
        " autocmd BufNew      * unsilent echom('========== BufNew:'      . expand('%'))
        " autocmd BufRead     * unsilent echom('========== BufRead:'     . expand('%'))
        " autocmd BufWinEnter * unsilent echom('========== BufWinEnter:' . expand('%'))
        " autocmd BufWinLeave * unsilent echom('========== BufWinLeave:' . expand('%'))
        " autocmd BufWipeout  * unsilent echom('========== BufWipeout:'  . expand('%')) 
        " autocmd FileType    * unsilent echom('========== FileType:'    . expand('%')) 
        " autocmd VimEnter    * unsilent echom('========== VimEnter:'    . expand('%'))
        " autocmd WinNew      * unsilent echom('========== WinNew:'      . expand('%'))
        " autocmd WinEnter    * unsilent echom('========== WinEnter:'    . expand('%'))
        " autocmd WinLeave    * unsilent echom('========== WinLeave:'    . expand('%'))
        " autocmd OptionSet   * unsilent echom('========== OptionSet:'   . expand('<amatch>'))
    augroup END
    " }}}
"}}}

" Plugin Config {{{

    " Airline {{{
        " if !exists('g:airline_theme')
        "     let g:airline_theme = 'molokai'
        " endif
        "
        " let g:airline_powerline_fonts = 1
        " if !exists('g:airline_symbols')
        "     let g:airline_symbols = {}
        " endif
        " let g:airline_symbols.space = "\ua0"
    " }}}

    " Buffergator {{{
        let g:buffergator_autoexpand_on_split = 0
        let g:buffergator_mru_cycle_local_to_window = 1
        let g:buffergator_mru_cycle_loop = 0
        let g:buffergator_sort_regime = "filepath"
        let g:buffergator_split_size = 15
        let g:buffergator_viewport_split_policy = "T"            

        " Commenting this out for now because BufferGator's MRU is not really
        " an MRU.
        "
        " let s:buffergator_alt_file_direction = 'prev'
        "                                          
        " function! s:GetBuffergatorAltFileDirection() 
        "     return s:buffergator_alt_file_direction
        " endfunction
        "                                          
        " function! s:BuffergatorAltFile(direction) 
        "     if a:direction ==# 'prev'
        "         execute 'BuffergatorMruCyclePrev'
        "         let s:buffergator_alt_file_direction = 'next'
        "     elseif a:direction ==# 'next'
        "         execute 'BuffergatorMruCycleNext'
        "         let s:buffergator_alt_file_direction = 'prev'
        "     endif
        " endfunction
    " }}}
   
    " Defx {{{

        " autocmd FileType defx call s:DefxSettings()
        "
        " function! s:DefxSettings() 
        "
        "     " Define mappings
        "     nnoremap <silent><buffer><expr> <CR> defx#do_action('open')
        "     nnoremap <silent><buffer><expr> ~    defx#do_action('cd')
        "     nnoremap <silent><buffer><expr> -    defx#do_action('cd', ['..'])
        "     nnoremap <silent><buffer><expr> u    defx#do_action('cd', ['..'])
        "     nnoremap <silent><buffer><expr> t    defx#do_action('open_or_close_tree')
        "     nnoremap <silent><buffer><expr> T    defx#do_action('open_tree_recursive')
        "     nnoremap <silent><buffer><expr> .    defx#do_action('toggle_ignored_files')
        "     nnoremap <silent><buffer><expr> yy   defx#do_action('yank_path')
        "     nnoremap <silent><buffer><expr> q    defx#do_action('quit')
        "     nnoremap <silent><buffer><expr> K    defx#do_action('new_directory')
        "     nnoremap <silent><buffer><expr> N    defx#do_action('new_file')
        "     nnoremap <silent><buffer><expr> M    defx#do_action('new_multiple_files')
        "     nnoremap <silent><buffer><expr> D    defx#do_action('remove')
        "     nnoremap <silent><buffer><expr> R    defx#do_action('rename')
        "
        "     " The mnemonic here is 'mark' (not s=select, to avoid key delay on
        "     " vim-surround's s key).
        "     nnoremap <silent><buffer><expr> m    defx#do_action('toggle_select')
        "     vnoremap <silent><buffer><expr> m    defx#do_action('toggle_select_visual')
        "
        "     " For some reason, mapping this key can cause all kinds of grief.
        "     " Unmap it and run '$ vim <dir>' in a terminal to see it.
        "     " nnoremap <silent><buffer><expr> <esc> defx#do_action('quit')
        " endfunction
        "
        " "
        " " The following is all about implementing some sort of sane buffer
        " " handling for for file browsing. That is:
        " "
        " " - Fully replace netrw with defx.
        " " - Proper alternate buffer handling when using defx (i.e. the defx
        " "   buffer _never_ becomes the alternate file).
        " "
        "
        " " autocmd FileType defx setlocal bufhidden=wipe 
        "
        " augroup defx_buffers
        "     autocmd!
        "     autocmd BufEnter,BufWinEnter
        "         \ * call s:explore(expand('<amatch>'))
        " augroup END
        "
        " function s:explore(path)
        "     " unsilent echom('explore:a:path: '    . a:path)
        "     " unsilent echom('explore:bufname: '   . bufname('%'))
        "     " unsilent echom('explore:bufnr: '     . bufnr('%'))
        "     " unsilent echom('explore:bufhidden: ' . &bufhidden)
        "     " unsilent echom('explore:abuf: '      . expand('<abuf>'))
        "     " unsilent echom('explore:filetype: '  . &filetype)
        "     " unsilent echom('explore:lines: '     . line('$'))
        "
        "     if a:path == '' || &filetype ==# 'defx' 
        "         return
        "     endif
        "
        "     " Handle ':edit ~'.
        "     let path = a:path
        "     if fnamemodify(path, ':t') ==# '~'
        "         let path = expand('~')
        "     endif
        "
        "     if isdirectory(path) 
        "
        "         " Disable netrw.
        "         augroup FileExplorer
        "             autocmd!
        "         augroup END
        "
        "         " The current buffer was opened with a directory path. We need
        "         " to wipe it out and replace it with a defx buffer on that same
        "         " path.
        "         bwipeout!
        "
        "         call defx#util#call_defx('Defx', path)
        "     endif
        " endfunction
    " }}}
    
    " Denite {{{
        " if executable('ag')
        "     call denite#custom#var('file/rec', 'command', 
        "         \ ['ag', '--follow', '--nocolor', '--nogroup', '-g', '']) 
        "
        "     call denite#custom#var('grep', 'command', ['ag'])
        "     call denite#custom#var('grep', 'default_opts', ['-i', '--vimgrep'])
        "     call denite#custom#var('grep', 'final_opts', [])
        "     call denite#custom#var('grep', 'pattern_opt', [])
        "     call denite#custom#var('grep', 'recursive_opts', [])
        "     call denite#custom#var('grep', 'separator', ['--'])
        "
        " elseif executable('rg')
        "     call denite#custom#var('file/rec', 'command', 
        "         \ ['rg', '--files', '--glob', '!.git'])
        "
        "     call denite#custom#var('grep', 'command', ['rg'])
        "     call denite#custom#var('grep', 'command', ['rg', '--threads', '1'])
        "     call denite#custom#var('grep', 'default_opts', ['--vimgrep', '--no-heading'])
        "     call denite#custom#var('grep', 'final_opts', [])
        "     call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
        "     call denite#custom#var('grep', 'recursive_opts', [])
        "     call denite#custom#var('grep', 'separator', ['--'])
        " endif
        "
        " call denite#custom#option('_', 'prompt', '>')
        " call denite#custom#option('_', 'direction', 'dynamictop')
        " call denite#custom#option('_', 'filter_split_direction', 'belowright')
        " call denite#custom#option('_', 'vertical_preview', 'true')
        "
        " " Not sure this is best for all colorschemes (is for quantum).
        " call denite#custom#option('_', 'highlight_matched_char', 'Special')
        "
        " call denite#custom#source('file/rec', 'matchers', ['matcher/regexp'])
        " call denite#custom#source('grep', 'matchers', ['matcher/regexp'])
        " call denite#custom#source('grep', 'converters', ['converter/abbr_word'])
        "
        " autocmd FileType denite call s:denite_my_settings()
        "
        " function! s:denite_my_settings() abort
        "     nnoremap <silent><buffer><expr> <CR> denite#do_map('do_action')
        "     nnoremap <silent><buffer><expr> d    denite#do_map('do_action', 'delete')
        "     nnoremap <silent><buffer><expr> i    denite#do_map('open_filter_buffer')
        "     nnoremap <silent><buffer><expr> p    denite#do_map('do_action', 'preview')
        "
        "     nnoremap <silent><buffer><expr> m    denite#do_map('toggle_select')
        "     nnoremap <silent><buffer><expr> M    denite#do_map('toggle_select_all')
        "
        "     nnoremap <silent><buffer><expr> <esc> denite#do_map('quit')
        "     nnoremap <silent><buffer><expr> q     denite#do_map('quit')
        " endfunction
        "
        " autocmd FileType denite-filter call s:denite_filter_my_settings()
        "
        " function! s:denite_filter_my_settings() abort
        "     " Quit filter window.
        "     imap <silent><buffer> <esc> <Plug>(denite_filter_quit)
        "
        "     " Quit filter window and denite.
	    "     imap <silent><buffer> <C-o> <Plug>(denite_filter_quit)q
        "
        "     " Move cursor while in insert mode.
        "     inoremap <silent><buffer> <C-j>
        "                 \ <Esc><C-w>p:call cursor(line('.')+1,0)<CR><C-w>pA
        "     inoremap <silent><buffer> <C-k>
        "                 \ <Esc><C-w>p:call cursor(line('.')-1,0)<CR><C-w>pA
        " endfunction
        "
        " nnoremap <leader>f :<C-u>Denite file -start-filter<cr>
        " nnoremap <leader>r :<C-u>Denite file/rec -start-filter<cr>
        " nnoremap <leader>R :<C-u>Denite grep -start-filter<cr>
        "
        " nnoremap <leader>p :<C-u>DeniteProjectDir file/rec -start-filter<cr>
        " nnoremap <leader>P :<C-u>DeniteProjectDir grep -start-filter<cr>
    " }}}
                                     
    " Lightline {{{
        " Like these: PaperColor, OldHope
        let g:lightline = {
        \   'colorscheme': 'PaperColor',
        \   'active': {
        \     'left': [ [ 'mode', 'paste' ],
        \               [ 'gitbranch', 'readonly', 'filename', 'modified' ] ]
        \   },
        \   'component_function': {
        \     'gitbranch': 'fugitive#head'
        \   },
        \ }
    " }}}

    " Miscellaneous {{{
        let g:rainbow_active = 1
    " }}}
   
    " Scratch {{{
        " let g:scratch_height = 0.4
        " let g:scratch_autohide = 0
        " let g:scratch_insert_autohide = 0
        let g:scratch_persistence_file=$HOME . '/.scratch.vim'
    " }}}

    " SuperTab {{{
        " <c-space> is gobally mapped to :buffer#, but there seems
        " to be no conflict here.
        " let g:SuperTabMappingForward = '<c-space>'
        " let g:SuperTabMappingBackward = '<s-c-space>'
        "
        " let g:SuperTabDefaultCompletionType = "context"
        " let g:SuperTabContextDefaultCompletionType = "<c-n>"
    " }}}
    
    " VimWiki {{{
        silent! nunmap <leader>ww
        silent! nunmap <leader>wi
        silent! nunmap <leader>ws
        silent! nunmap <leader>wt
        silent! nunmap <leader>w<leader>t
        silent! nunmap <leader>w<leader>w
        silent! nunmap <leader>w<leader>i
        silent! nunmap <leader>w<leader>m
        silent! nunmap <leader>w<leader>y

        nmap <leader>vw <Plug>VimwikiIndex
        nmap <leader>vi <Plug>VimwikiTabIndex
        nmap <leader>vs <Plug>VimwikiUISelect
        nmap <leader>vr <Plug>VimwikiRenameLink
        nmap <leader>vdw <Plug>VimwikiDiaryIndex
        nmap <leader>vdt <Plug>VimwikiTabMakeDiaryNote
        nmap <leader>vdn <Plug>VimwikiMakeDiaryNote
        nmap <leader>vdg <Plug>VimwikiDiaryGenerateLinks

        autocmd FileType vimwiki setlocal textwidth=78
    " }}}
" }}}

" Functions {{{

    " Dump output of an ex command to a new buffer in a new tab. Primarily
    " useful for searching ex command output.  
    " Example: :TabMessage map
    " 
    function! TabMessage(cmd)
      redir => message
      silent execute a:cmd
      redir END
      if empty(message)
        echoerr "no output"
      else
        " use "new" instead of "tabnew" below if you prefer split windows instead of tabs
        tabnew
        setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted nomodified
        silent put=message
      endif
    endfunction
    command! -nargs=+ -complete=command TabMessage call TabMessage(<q-args>)

    " Wanted to have <c-n> run invnumber and <c-r> run invrelativenumber so I
    " could toggle these independently, but <c-r> is redo and I didn't want to
    " mess with that. With this function I can just cycle through using a
    " single key.
    "
    function! CycleNumber() 
        if ! &number && ! &relativenumber
            set number
        elseif &number && ! &relativenumber
            set relativenumber
        else
            set nonumber
            set norelativenumber
        endif
    endfunction


    function! FormatCss()

        " TODO: Make sure we're in css buffer?

        "
        " Decontstruct the file to a consistent format from which
        " we can reliably reconstruct it.
        "

        silent %s///g                       " Just in case, delete any control-M's.
        silent %s/\s*$//g                     " Remove trailing whitespace on all lines.
        silent %s/\s\+/ /g                    " Replace multiple whitespace with single space.
        silent g/^\s*$/d                      " Delete all blank lines.
        silent %s/\n//g                       " Remove all carriage returns.

        "
        " Reformat the deconstructed file.
        "
        
        silent %s/\*\//*\/\r\r/g              " Two newlines after comment lines.
        silent %s/}/}\r\r/g                   " Two newlines after }.
        silent %s/{/{\r/g                     " Newline after {.
        silent %s/;/;\r/g                     " Newline after ;.
        silent %s/^\(\s*\S\+.*\)}$/\1\r}/g    " Newline before ).

        " TODO: There's a potential issue with sorting attributes in
        " that the original css could have multiple attributes, with
        " the last one not being terminated with a ';'. In this case,
        " sorting could move that attribute to the middle of the list,
        " which, without the ';', would be invalid html. Therefore,
        " we'll simply return here until we account for this.

        return

        "
        " Sort attributes.
        "

        " Start at top of file.
        normal gg

        while search("{$", "W")
            +1
            let first = line(".")

            /}
            -1
            let last = line(".")

            execute first . "," . last . "sort"
        endwhile

        " Indent file.
        normal gg=G

    endfunction

    nmap <silent> _c :call FormatCss()<CR>

" }}}

" TODO / etc {{{
"
"   - Snippets
"
"   - Tags
"
"   - Copy character from line above/below?.
"
"   - I have some diff mode stuff configured here (see the VimDiff and windo
"   keymappings above). It would be nice if we did a 'diffoff' while in a Vim
"   Fugitive diff, that we delete the git index buffer.
"
"   - Some interesting things I see in Nate Neff's vim github project:
"
"     <Space>    Show recent buffers at bottom of screen.
"                Use 'f' and 'b' to move back & forth between them.
"                Thanks to bufmru plugin author!
"
"     # NERD Commenter
"     
"      <leader>ci      Comment / Uncomment line(s)
"      <leader>cu      UN-comment line(s)
"      <leader>cl      Comment lines
"     
" }}}

" I (or preceeding blank) am only here to ensure last fold doesn't misbehave.
