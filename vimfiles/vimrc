" Modeline & Notes {{{
" vim: set sw=4 ts=4 sts=4 et tw=79 foldlevel=0 foldmethod=marker foldmarker={{{,}}}:
"
" My .vimrc - Always needs lots of work. See the TODO section for things on
" the list.
"
"   Development Notes {{{
"     Debugging: Can insert 'echom "<msg>"' to show mesages in the cmd window.
"     These typically will disappear when output from .vimrc but can be
"     displayed with ':messages'.
"
"     An interesting vim debugging link:
"         https://codeinthehole.com/tips/debugging-vim-by-example/
"
"   }}}
" }}}

" Environment {{{
    if &compatible
      set nocompatible
    endif

    silent function! OSX()
        return has('macunix')
    endfunction

    silent function! LINUX()
        return has('unix') && !has('macunix') && !has('win32unix')
    endfunction

    silent function! WINDOWS()
        return  (has('win32') || has('win64'))
    endfunction

    if WINDOWS()
        set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
    endif
" }}}

" Debugging {{{
    " augroup vimrc_debug
    "     autocmd!
    "     autocmd BufCreate   * unsilent echom('========== BufCreate:'   . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufEnter    * unsilent echom('========== BufEnter:'    . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufFilePre  * unsilent echom('========== BufFilePre:'  . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufFilePost * unsilent echom('========== BufFilePost:' . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufHidden   * unsilent echom('========== BufHidden:'   . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufLeave    * unsilent echom('========== BufLeave:'    . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufNew      * unsilent echom('========== BufNew:'      . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufRead     * unsilent echom('========== BufRead:'     . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufWinEnter * unsilent echom('========== BufWinEnter:' . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufWinLeave * unsilent echom('========== BufWinLeave:' . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd BufUnload   * unsilent echom('========== BufUnload:'   . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%')) 
    "     autocmd BufWipeout  * unsilent echom('========== BufWipeout:'  . expand('<abuf>') . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%')) 
    "     autocmd FileType    * unsilent echom('========== FileType:'    . expand('%')) 
    "     autocmd VimEnter    * unsilent echom('========== VimEnter:'    . expand('%'))
    "     autocmd WinNew      * unsilent echom('========== WinNew:'      . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd WinEnter    * unsilent echom('========== WinEnter:'    . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd WinLeave    * unsilent echom('========== WinLeave:'    . expand('%')      . ';winid:' . win_getid() . ';filetype:' . &filetype . ':bufname(%)=' . bufname('%'))
    "     autocmd OptionSet   * unsilent echom('========== OptionSet:'   . expand('<amatch>'))
    " augroup END
" }}}

" Install Plugins {{{
    call plug#begin('~/.vim/plugged')

        Plug 'ljohnston/vim-confirmquit'

        Plug 'flazz/vim-colorschemes'
        Plug 'itchyny/lightline.vim'
        
        Plug 'preservim/nerdtree', { 'tag': '6.10.16' }

        Plug 'junegunn/fzf.vim'
        if !empty(glob('/usr/local/opt/fzf'))
            echom("intel")
            Plug '/usr/local/opt/fzf'
        elseif !empty(glob('/opt/homebrew/opt/fzf'))
            echom("silicon")
            Plug '/opt/homebrew/opt/fzf'
        endif

        Plug 'tpope/vim-abolish'
        Plug 'tpope/vim-fugitive'
        Plug 'tpope/vim-surround'

        Plug 'easymotion/vim-easymotion'

        Plug 'jlanzarotta/bufexplorer'

        Plug 'luochen1990/rainbow'
        " Plug 'mtth/scratch.vim'
        Plug 'ljohnston/scratch.vim'
        " Plug 'ervandew/supertab'
        Plug 'vim-scripts/VimCompletesMe'
        Plug 'scrooloose/syntastic'
        Plug 'godlygeek/tabular'
        Plug 'tpope/vim-commentary'
        Plug 'tyru/open-browser.vim'

        Plug 'jiangmiao/auto-pairs'

        Plug 'vim-scripts/groovyindent-unix'
        Plug 'udalov/kotlin-vim'
        Plug 'rodjek/vim-puppet'
        Plug 'hashivim/vim-terraform'
        Plug 'Einenlum/yaml-revealer'
        
        Plug 'vimwiki/vimwiki', { 'tag': 'v2023.04.04_1' }
    call plug#end()

    if exists("g:plugin_install") && g:plugin_install == 1 
        finish
    endif
" }}}

" Altbuf {{{

    " TODO (for a real plugin):
    " - check compatible
    " - global configuration options, defaults
    " - min vim version check?
    
    " TODO (issues):

    "
    " autocmd event notes
    " - We get a bdelete on a bwipeout
    " - Some plugins seem to do weird things with the events. For example,
    "   netrw fires a BufEnter event before the buffer has a name and then
    "   fires two (yes, two) BufDelete events. It isn't until the second
    "   BufDelete that the buffer's filetype is correctly set to netrw. 
    "   On the BufEnter, buflisted=1.
    "   
    
    command! -nargs=0 AltbufPrevious :call AltbufPrevious()

    augroup altbuf
        autocmd!
        autocmd BufEnter,WinEnter * call s:AltbufEnter()
        autocmd BufDelete         * call s:AltbufDelete()
        autocmd WinLeave          * call s:AltbufWinLeave()
        autocmd WinNew            * call s:AltbufWinNew()
    augroup END

    function! s:AltbufDebugMsg(msg)
        " unsilent echom(a:msg)
    endfunction

    function! s:AltbufDebug(event)
        call s:AltbufDebugMsg('--------------------')
        call s:AltbufDebugMsg(a:event . ':<abuf>=' . expand('<abuf>'))
        call s:AltbufDebugMsg(a:event . ':filetype=' . &filetype)
        call s:AltbufDebugMsg(a:event . ':buflisted=' . &buflisted)
        call s:AltbufDebugMsg(a:event . ':bufname(%)=' . bufname('%'))
        call s:AltbufDebugMsg(a:event . ':winnr()=' . winnr())
        call s:AltbufDebugMsg('--------------------')
    endfunction

    let s:winBufDict = {}
    let s:globalBufList = []

    " TODO: Make these configurable plugin options.
    let s:includeFiletypes = ['help']
    let s:excludeFiletypes = ['netrw']

    " Ignore buffers with empty name (e.g. "[No Name]" buffers)
    let s:excludeBufnames = ['^\s*$']
    let s:excludeBufnames += ['\c.*buffergator.*']


    function! s:AltbufEnter()
        call s:AltbufDebugMsg('altbufEnter:@%=' . @%)
        call s:AltbufDebugMsg('altbufEnter:@#=' . @#)
        call s:AltbufDebugMsg('altbufEnter:<abuf>=' . expand('<abuf>'))
        call s:AltbufDebugMsg("altbufEnter:filetype=" . &filetype)
        call s:AltbufDebugMsg('altbufEnter:win_getid()=' . win_getid())
        call s:AltbufDebugMsg("altbufEnter:winBufDict=" . string(s:winBufDict))

        " We'll take this as another opportunity to prune inactive windows. See
        " the AltbufWinLeave function header for more info.
        call s:PruneWinDict()

        let l:winid = win_getid()
        let l:bufnr = str2nr(expand('<abuf>'))

        if s:IsExcludedBufname(bufname(l:bufnr)) 
            return
        endif 

        if !has_key(s:winBufDict, l:winid)
            let s:winBufDict[l:winid] = []
        endif

        " Remove buffer from window-specific list if it exists, and put it on top.
        let l:winBufList = get(s:winBufDict, l:winid)
        call s:RemoveListElement(l:winBufList, l:bufnr)
        call insert(l:winBufList, l:bufnr, 0)

        " Same for the global buffer list.
        call s:RemoveListElement(s:globalBufList, l:bufnr)
        call insert(s:globalBufList, l:bufnr, 0)

        call s:AltbufDebugMsg("altbufEnter(end):winBufDict=" . string(s:winBufDict))
    endfunction

    function! s:AltbufDelete()
        call s:AltbufDebugMsg('altbufDelete:@%=' . @%)
        call s:AltbufDebugMsg('altbufDelete:@#=' . @#)
        call s:AltbufDebugMsg('altbufDelete:<abuf>=' . expand('<abuf>'))
        call s:AltbufDebugMsg("altbufDelete:filetype=" . &filetype)
        call s:AltbufDebugMsg('altbufDelete:win_getid()=' . win_getid())
        call s:AltbufDebugMsg("altbufDelete:winBufDict=" . string(s:winBufDict))

        " Prune the windows first for efficiency.
        call s:PruneWinDict()

        " We can't just rely on PruneBuffers() here because the buffer that's
        " being deleted still exists when this event fires.
        let l:bufnr = str2nr(expand('<abuf>'))
        call s:PruneWinBufLists(l:bufnr)
        call s:RemoveListElement(s:globalBufList, l:bufnr)

        call s:PruneBuffers()

        call s:AltbufDebugMsg("altbufDelete(end):winBufDict=" . string(s:winBufDict))
    endfunction

    "
    " Initialize any new windows with the global buffer list.
    " Why we need to... from a user experience standpoint, multiple windows can
    " get strange with regard to our Altbuf intentions. For example, if a user
    " has a window open with a number of buffers open and creates a new split
    " (e.g. a simple ':vsplit'), then they're looking at two windows with the
    " same buffer. If they close one of those windows, which one did they
    " close... the one with a bunch of buffer history or the new one? From the
    " user perspective, it's kind of hard to say, so it makes sense to push
    " the current buffer history to each new window.
    "
    function! s:AltbufWinNew() 
        call s:AltbufDebugMsg('altbufWinNew:@%=' . @%)
        call s:AltbufDebugMsg('altbufWinNew:@#=' . @#)
        call s:AltbufDebugMsg('altbufWinNew:<abuf>=' . expand('<abuf>'))
        call s:AltbufDebugMsg("altbufWinNew:filetype=" . &filetype)
        call s:AltbufDebugMsg('altbufWinNew:win_getid()=' . win_getid())
        call s:AltbufDebugMsg("altbufWinNew:winBufDict=" . string(s:winBufDict))

        let s:winBufDict[win_getid()] = copy(s:globalBufList)
    endfunction

    "
    " There is no such thing as a WinDelete event, so the active window still
    " exists when we get the leave event. As a result, the window that
    " triggered this event won't be removed from the Altbuf state. Any other
    " windows that are no longer active, however, will. This is just taking
    " advantage of an opportunity to keep our state as accurate as possible.
    "
    function! s:AltbufWinLeave()
        call s:AltbufDebugMsg('altbufWinLeave:@%=' . @%)
        call s:AltbufDebugMsg('altbufWinLeave:@#=' . @#)
        call s:AltbufDebugMsg('altbufWinLeave:<abuf>=' . expand('<abuf>'))
        call s:AltbufDebugMsg("altbufWinLeave:filetype=" . &filetype)
        call s:AltbufDebugMsg('altbufWinLeave:win_getid()=' . win_getid())
        call s:AltbufDebugMsg("altbufWinLeave:winBufDict=" . string(s:winBufDict))

        call s:PruneWinDict()
        call s:PruneBuffers()
        
        call s:AltbufDebugMsg("altbufDelete(end):winBufDict=" . string(s:winBufDict))
    endfunction

    "
    " Remove any windows that no longer exist from Altbuf state.
    "
    function! s:PruneWinDict()
        call s:AltbufDebugMsg("pruneWinDict:winBufDict=" . string(s:winBufDict))

        let l:winids = keys(s:winBufDict)

        for winid in l:winids
            if win_id2win(winid) == 0
                call remove(s:winBufDict, winid)
            endif
        endfor

        call s:AltbufDebugMsg("pruneWinDict(end):winBufDict=" . string(s:winBufDict))
    endfunction

    "
    " Remove any buffers that no longer exist from Altbuf state.
    "
    function! s:PruneBuffers()
        call s:AltbufDebugMsg("pruneBuffers:winBufDict=" . string(s:winBufDict))
        let l:bufnrs = []

        for winid in keys(s:winBufDict)
            let l:bufnrs += get(s:winBufDict, winid)
        endfor
        
        call s:AltbufDebugMsg("PruneBuffers:" . string(l:bufnrs))

        for bufnr in uniq(sort(l:bufnrs))
            if ! bufexists(bufnr)
                call s:PruneWinBufLists(bufnr)
            endif
        endfor

        call s:AltbufDebugMsg("pruneBuffers(end):winBufDict=" . string(s:winBufDict))
    endfunction

    "
    " Remove a buffer from all Altbuf window state.
    "
    function! s:PruneWinBufLists(bufnr)
        call s:AltbufDebugMsg("PruneWinBufLists:bufnr=" . string(a:bufnr))

        for winid in keys(s:winBufDict)
            let l:bufList = get(s:winBufDict, winid)
            call s:RemoveListElement(l:bufList, a:bufnr)
        endfor
    endfunction

    function! s:EnsureListElement(list, element)
        if index(a:list, a:element) == -1
            call add(a:list, a:element)
        endif
    endfunction

    function! s:RemoveListElement(list, element)
        let l:idx = index(a:list, a:element)

        if l:idx >= 0
            call remove(a:list, l:idx)
        endif
    endfunction

    function s:IsExcludedBufname(bufname)
        call s:AltbufDebugMsg('IsExcludedBufname:bufname=' . a:bufname)

        for pattern in s:excludeBufnames
            if a:bufname =~ pattern
                call s:AltbufDebugMsg('IsExcludedBufname:excluding:' . a:bufname)
                return 1
            endif
        endfor

        return 0
    endfunction

    function! s:IsExcludedBuf(bufnr)

        let l:filetype = getbufvar(a:bufnr, '&filetype')

        " Excludes take precedence.
        if index(s:excludeFiletypes, l:filetype) >= 0
            return 1
        endif

        if s:IsExcludedBufname(bufname(a:bufnr)) 
            return 1
        endif 

        " Include filetypes take precedence over unlisted bufs.
        if index(s:includeFiletypes, l:filetype) >= 0
            return 0
        endif

        if !buflisted(a:bufnr)
            return 1
        endif

        return 0
    endfunction

    function! AltbufList()
        echom('winBufDict=' . string(s:winBufDict))
        echom('globalBufList=' . string(s:globalBufList))
    endfunction

    function! AltbufPrevious()
        let l:winBufList = get(s:winBufDict, win_getid())
        let l:bufListLen = len(l:winBufList)

        if l:bufListLen < 2
            return
        endif

        while l:bufListLen > 1 && s:IsExcludedBuf(l:winBufList[1])
            call remove(l:winBufList, 1)
            let l:bufListLen -= 1
        endwhile

        if l:bufListLen > 1
            execute 'buffer' . l:winBufList[1]
        endif
    endfunction
" }}}

" General {{{
    filetype plugin indent on
    syntax enable

    scriptencoding utf-8
    set encoding=utf-8

    set fileformats=unix 
    set history=100
    set ttyfast                             

    set nofileignorecase                    "case-sensitive file completion

    set ruler                               "show cursor position

    set scrolloff=3                         "context lines when scrolling
    set sidescrolloff=5                     "context columns when scrolling

    set laststatus=2                        "always show status line
    set showmode                            "display mode at bottom of screen
    set showcmd                             "show commands at bottom of screen

    set colorcolumn=81                      "make 80 columns obvious

    augroup CursorLine
        autocmd!
        autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline
        " autocmd WinLeave * 
            \  if &filetype !~ '^\(denite\|foo\)$' 
            \|     setlocal nocursorline
            \| endif
    augroup END

    set nostartofline                       "try to leave cursor in same column
    set virtualedit=all                     "allow cursor where no actual characters exist

    set backspace=indent,eol,start          "a better backspace

    set autoread                            "detect external file changes
    set hidden                              "change buffers without saving

    set showmatch                           "show matching character pair

    "set wildmenu                            "enhanced autocomplete
    "set wildmode=longest,list,full          "autocomplete behavior
    set wildmenu                            "enhanced autocomplete
    set wildmode=longest,full               "autocomplete behavior

    set ignorecase                          "ignore case in search, regex
    set smartcase                           "only ignore case if pattern is all lower

    set hlsearch                            "highlight search results
    set incsearch                           "search incremntally

    set shortmess+=filmnrxoOtT              "abbreviate messages (avoids 'hit enter')
    set cmdheight=1                         "command line rows

    set autoindent                          "indent at same level as previous line
    set smartindent                         "add indent for code blocks

    set expandtab                           "tabs as spaces
    set shiftwidth=4
    set softtabstop=4

    autocmd BufEnter * silent! lcd %:p:h    "cwd tracks current file

    " Silence the bell.
    set noerrorbells visualbell t_vb=
    autocmd GUIEnter * set visualbell t_vb=

    if has('clipboard')
        if has('unnamedplus')  
            " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        else         
            " On mac and Windows, use * register for copy-paste
            set clipboard=unnamed
        endif
    endif

    " Directories
    set backupdir=~/.vim/.backup//
    set directory=~/.vim/.swp//
    set undodir=~/.vim/.undo//
    set viewdir=~/.vim/.view

    " Strip trailing whitespace from these files.
    augroup whitespace
        autocmd!
        autocmd FileType groovy,java,kotlin,python,puppet,ruby,scala,sh,terraform,yaml
            \ autocmd BufWritePre <buffer> %s/\s\+$//e
    augroup END
" }}}

" UI {{{

    " GUI {{{

        " Note that gui commands that have any meaning with regard to
        " 'gui_running' include only 'guicursor', 'guifont', 'guipty', and
        " 'guioptions'. Note also that gui apps for neovim do not have
        " 'gui_running', nor do they support any of those gui commands. For the
        " OS X vimR at least, the font is set through normal OS X app
        " preferences.
        if has("gui_running")

           " 
           " For a good resource regarding how to pick and set a font, see:
           "
           "   http://www.scholarslab.org/grad-student-research/vim-gui-font-magic/
           "

           if OSX()
               if !has('gui_vimr')
                   set guifont=SourceCodeProForPowerline-Regular:h16
                   set columns=160
                   set lines=40
               endif
           elseif LINUX()
               set guifont=SourceCodeProForPowerline-Regular:h18
               set columns=120
               set lines=52
           else
               set guifont="Courier 10 Pitch":h10
               set columns=120
               set lines=64
           endif

           set guioptions-=T           " turn off the toolbar
           set guioptions-=l           " no scrollbars on the left
           set guioptions-=L           " no scrollbars on the left
           set guioptions-=r           " no scrollbars on the right
           set guioptions-=R           " no scrollbars on the right

           " turn off cursor blinking
           set guicursor+=a:blinkon0
        endif
    " }}}

    " {{{ colorscheme 
        " set background=light

        " colorscheme onedark
        " colorscheme professional
        " colorscheme molokai
        " colorscheme solarized
        " colorscheme desert
        " colorscheme neodark
        colorscheme quantum
        
        "
        " I'm not interested in creating my own versions of various color
        " schemes. I do, however, want to be able to tweak the ones I use if
        " necessary, so we'll do that here.
        "
        " TODO: Is there a better way to achieve the tweaks we want? Answer:
        " Yes, see https://github.com/vim-scripts/AfterColors.vim
        " 

        "
        " Got the following colorscheme stuff from:
        "
        " https://github.com/megaannum/colorschemer/blob/master/autoload/colorschemer/viewer.vim
        "

        let s:colorsname = ""

        function! s:GetColorSchemeName()
          if exists("g:colors_name")
            return g:colors_name
          else
            if exists("s:colorsname")
              unlet s:colorsname
            endif

            execute "redir => s:colorsname"
            silent execute "colorscheme"
            execute "redir END"
            let s:colorsname = s:colorsname[1:]
            return s:colorsname
          endif
        endfunction
        
        let cname = s:GetColorSchemeName()
        
        if cname == 'molokai'
            " Better cursor line colors.
            highlight CursorLine guibg=Gray27 ctermbg=238
            highlight CursorColumn guibg=Gray27 ctermbg=238
        
            " Default column color (i.e. column 80 indicator) sucks (it's red!).
            " highlight ColorColumn guibg=DarkSlateGray
        
            " Default comment color too dark.
            highlight Comment guifg=SkyBlue3 ctermfg=67
        
            " Default visual selection needs more contrast.
            highlight Visual guifg=Gray30 guibg=NavajoWhite
            " highlight Visual guibg=gray30
        elseif cname == 'neodark'
            highlight Normal guibg=gray18
        elseif cname == 'onedark'
            " highlight Comment guifg=SlateGray4 ctermfg=67
        elseif cname == 'professional'
            highlight ColorColumn guibg=BlanchedAlmond
        elseif cname == 'quantum'
            highlight CursorLine guibg=gray27 ctermbg=242
            highlight Folded guifg=#658494 ctermfg=9

            " A total hack for the time being for VimR.
            if has('nvim')
                highlight Search guibg=BlanchedAlmond guifg=NONE
            endif
        elseif cname == 'solarized' || cname == 'desert'
            highlight ColorColumn guibg=DarkSlateGray
        endif
        
    " }}}
" }}}

" {{{ Key Mappings
    "
    " Some useful key mapping links:
    " - https://raddevon.com/articles/what-to-do-when-a-vim-keymap-doesnt-work/
    "
    " Some useful key mapping commands:
    " - :help index - Shows keys mapped by vim
    " - :map <key> - Show current mapping for <key>
    " - :verbose map <key> - Show current mapping for <key> and where it was
    "   set
    "
    " Several ctrl key combinations aren't recognized by vim. To test if a ctrl
    " key is recognized:
    " - Go to insert mode
    " - Press ^v followed by desired ctrl key combination
    " - If the corresponding ctrl character is entered the key is recognized
    " - If only the key paired with the ctrl key is entered, the key is not
    "   recognized
    "
    " Note also that several ctrl key combinations are overloaded as other
    " keys (e.g. ctrl-h is backspace, ctrl-i is tab, etc.). This is fine if
    " mapped in normal or visual modes. In insert mode, however, these keys
    " either can't be mapped or can't be mapped without affecting the
    " corresponding key. For example:
    "
    "   - ctrl-h can not be remapped in insert mode (it simply remains a
    "     backspace)
    "   - ctrl-i can be remapped in insert mode and behave as expected, but it
    "     will remap the tab key to the same action.
    "
    
    let mapleader = "\<Space>"
    let g:mapleader = "\<Space>"

    :nnoremap <leader>ve :vsplit ~/.vimrc<cr>

    noremap <leader>gs :Git<cr>
    noremap <leader>gb :Git blame<cr>
    noremap <leader>gl :Git log<cr>

    " noremap gyy :YamlGetFullPath<cr>
    " noremap gyp :YamlGoToParent<cr>

    " Wrapped lines goes down/up to next row, rather than next line in file.
    noremap j gj
    noremap k gk

    " scroll up/down without moving the cursor
    noremap <c-k> 1<c-u>
    noremap <c-j> 1<c-d>

    " Some cool stuff I got from http://howivim.com/2015/steve-francia/ {{
    " Visual shifting (does not exit Visual mode)
    vnoremap < <gv
    vnoremap > >gv

    nnoremap < <l
    nnoremap > >l
                     
    " This is primarily to get the insert mode mappings, but
    " might as well configure the same for insert and visual.
    vnoremap <c-s>, <gv
    vnoremap <c-s>. >gv
    nnoremap <c-s>, <l
    nnoremap <c-s>. >l
    inoremap <c-s>, <c-o><l
    inoremap <c-s>. <c-o>>l

    " Allow using the repeat operator with a visual selection (!)
    vnoremap . :normal .<CR>

    nnoremap Y y$

    " Use the black hole register to paste without overwriting the unnamed
    " register.
    vnoremap p "_dP

    " Overwrite current character with one from line above. NOTE that this ONLY
    " works with "virtualedit" equals "all". To do this right, we'd probably need a
    " function that could save, set, restore vitualedit. And would (hopefully?) be
    " more efficient (as this is VERY slow).
    " nnoremap <c-k> kyljv"0pl
    " inoremap <c-k> <esc>lkyljv"0pli
    
    " Insert a semi-colon at EOL.
    nnoremap <expr> <c-s>; getline('.')[-1:] == ';' ? '' : 'mxA;<esc>`x'
    inoremap <expr> <c-s>; getline('.')[-1:] == ';' ? '' : '<Esc>lmxA;<Esc>`xi'

    " Tab navigation.
    nnoremap <S-H> gT
    nnoremap <S-L> gt

    " Beginning / end of line.
    " nnoremap <c-h> ^
    " nnoremap <c-l> $

    " These become useful when using an auto-close plugin.
    " inoremap <c-h> <c-o>h
    " inoremap <c-l> <c-o>l

    "
    " Command mode mappings.
    " Note that these match cvim.
    "

    " forward/backward char
    cnoremap <c-l> <right>
    cnoremap <c-h> <left>

    " forward/backward word
    cnoremap <c-y> <s-left>
    cnoremap <c-o> <s-right>

    " begin/end of line
    " default begin: <c-b> 
    "   default end: <c-e> 

    " up/down line
    cnoremap <c-j> <down>
    cnoremap <c-k> <up>

    " delete char / word
    cnoremap <c-x> <del>
    " default word: <c-w>

    " Write buffers.
    nnoremap <leader>w :write<cr>
    nnoremap <leader>W :wall<cr>

    " Delete buffer.
    nnoremap <c-o> :bdelete<cr>
    
    " Goto previous buffer.
    nnoremap <silent> <leader><leader> :AltbufPrevious<cr>

    " Ideally, used in split window with desired diff buffers open.
    nnoremap <leader>dt :windo diffthis<CR>
    nnoremap <leader>do :windo diffoff<CR>
    nnoremap <leader>du :diffupdate<CR>

    " Build with gradle.
    " nnoremap <leader>gb :compiler gradlew<CR> :make compile<CR>
    " nnoremap <leader>gt :compiler gradlew<CR> :make test<CR>

    "
    " <C-o> instead of <esc> to reduce side-effects. More here:
    "
    "   http://vim.wikia.com/wiki/Use_Ctrl-O_instead_of_Esc_in_insert_mode_mappings
    "

    nnoremap <C-\> :set cursorcolumn!<cr>
    imap <C-\> <C-o><C-\>

    " open line below while in insert mode
    imap <C-o> <C-o>o

    " Delete to beginning of line and insert
    nnoremap <C-c> cc
    inoremap <C-c> <C-o>cc

    " <tab> to move to matching paren, bracket, etc.
    nnoremap <tab> %
    vnoremap <tab> %

    " Toggle line numbers.
    nnoremap <C-n> :call CycleNumber()<cr>
    imap <C-n> <C-o><C-n>

    " Turn current highlight off.
    nnoremap <silent> <leader>/ :noh<cr>

    " nnoremap <leader>h i/* ----------------  ---------------- */<esc><b><b>i

    " Search for my section headers.
    nnoremap <leader>s /^.*-\{40,80}\n^.*\[.*\]\s*\_.\{-}-\{40,80}\s*$<cr>

    "
    " Plugin-related global key mappings (buffer local plugin mappings in
    " "Plugin Config" section below).
    "
    
    nnoremap <leader>e :execute 'edit' . getcwd()<cr>

    " fzf
    nnoremap <leader>pf :FzfProjectFiles<cr> 
    nnoremap <expr> <leader>ps IsInProject() ? ':FzfProjectRg<space>' : '' 

    nnoremap <leader>rf :Files<cr>
    nnoremap <leader>rs :Rg<space>
" }}}

" Autocommands {{{

    " gradle {{{
        autocmd BufNewFile,BufRead *.gradle setfiletype groovy
    " }}}
    
    " python {{{
        " python comment indents are all hosed up. This will fix it.
        " See: http://stackoverflow.com/questions/2360249
        autocmd BufRead,BufNewFile *.py inoremap # X<c-h>#<space>
    " }}}
    
    " shell scripts {{{
        autocmd FileType sh setlocal shiftwidth=2
        autocmd FileType sh setlocal softtabstop=2
    " }}}
    
    " ruby {{{
        autocmd FileType ruby setlocal shiftwidth=2 
        autocmd FileType ruby setlocal softtabstop=2 
    " }}}

    " terrafrom {{{
        autocmd FileType terraform setlocal shiftwidth=2 
        autocmd FileType terraform setlocal softtabstop=2 
        autocmd FileType terraform setlocal commentstring=#\ %s
    " }}}
    
    " vimdiff {{{
        augroup VimDiff
            autocmd!
            autocmd VimEnter,FileWritePre * 
                \   nnoremap <expr> <C-j> &diff ? ']c' : '<Nop>' 
                \ | nnoremap <expr> <C-k> &diff ? '[c' : '<Nop>'
                \ | nnoremap <expr> <leader>dg &diff ? ':diffget<CR>' : '<Nop>'
                \ | nnoremap <expr> <leader>dp &diff ? ':diffput<CR>' : '<Nop>'
                \ | if &diff | set diffopt=filler,context=10000 | endif
        augroup END
    " }}}

    " yaml {{{
        autocmd FileType yaml setlocal shiftwidth=2 
        autocmd FileType yaml setlocal softtabstop=2 
        autocmd FileType yaml setlocal commentstring=#\ %s
    " }}}

    " .vimrc {{{
        " prevent .vimrc modeline from closing all our folds on save
        autocmd! BufWritePre .vimrc setlocal nomodeline
    " }}}

    " {{{ text
        autocmd BufRead,BufNewFile *.txt setlocal textwidth=72
        autocmd BufRead,BufNewFile *.txt setlocal formatoptions=tq

        " Turn off handling of '-' as a bullet (sort of).
        autocmd BufRead,BufNewFile *.txt setlocal comments-=fb:-
    " }}}
"}}}

" Plugin Config {{{

    " Airline {{{
        " if !exists('g:airline_theme')
        "     let g:airline_theme = 'molokai'
        " endif
        "
        " let g:airline_powerline_fonts = 1
        " if !exists('g:airline_symbols')
        "     let g:airline_symbols = {}
        " endif
        " let g:airline_symbols.space = "\ua0"
    " }}}
    
    " BufExplorer {{{
        let g:bufExplorerDisableDefaultKeyMapping=1
        let g:bufExplorerSortBy='fullpath'
        let g:bufExplorerSplitBelow=0
        let g:bufExplorerSplitHorzSize=15

        " My IntelliJ buffer switcher uses <c-j>, <c-k>, etc. so I don't
        " have to use arrow keys. This creates same behavior here.
        autocmd FileType bufexplorer
            \  map <buffer> <c-j> j
            \| map <buffer> <c-k> k
            \| map <buffer> <Esc> q

        " BufExplorer kinda sucks... if you try and open it with
        " no buffers open (excluding "No Name" buffers, whose name 
        " is actually returned as "") it throws errors.
        nnoremap <silent> <leader>b :call OpenBufExplorer()<cr>

        function! OpenBufExplorer()
            let l:bufNums = range(1, bufnr('$'))
            let l:bufList = filter(l:bufNums, 'buflisted(v:val) && bufname(v:val) != ""')

            if len(l:bufList) > 0
                execute 'BufExplorerHorizontalSplit'
            else
                echo 'No buffers'
            endif
        endfunction

    " }}}


    " EasyMotion {{{
        map s <Plug>(easymotion-prefix)
    " }}}
    
    " Fzf {{{
        function s:FzfProjectFiles(path, bang)
            let root = empty(a:path) ? s:ProjectRoot() : a:path

            if empty(root)
                return s:warn('Not in a project')
            endif

            let options = '-m --prompt "' . fnamemodify(root, ':t') . '> "'
            return fzf#vim#files(root, { 'options': options }, a:bang)
        endfunction

        function s:FzfProjectRg(query, bang)
            let root = s:ProjectRoot()

            if empty(root)
                return s:warn('Not in a project')
            endif

            " Change to project root instead of passing on rg command line so that
            " all file results are relative to project root.
            execute 'cd ' . root
            call fzf#vim#grep(
                \ 'rg --column --line-number --no-heading --color=always --smart-case -- '
                \     .shellescape(a:query), a:bang)
        endfunction

        function IsInProject()
            if empty(s:ProjectRoot())
                return s:warn('Not in a project')
            endif
            return 1
        endfunction

        "
        " FzfProjectFiles doesn't really need to be a command, but FzfProjectRg
        " does so that we can allow the user to enter the string to grep for.
        " This, along with the above functions and the key mappings are kinda
        " hackey, but it is what it is, at least for the time being.
        " 
        
        command! -bang -nargs=* -complete=dir FzfProjectFiles call s:FzfProjectFiles(<q-args>, <bang>0)
        command! -bang -nargs=* FzfProjectRg call s:FzfProjectRg(<q-args>, <bang>0)
    " }}}

    " Lightline {{{
        " Like these: PaperColor, OldHope
        let g:lightline = {
        \   'colorscheme': 'PaperColor',
        \   'active': {
        \     'left': [ [ 'mode', 'paste' ],
        \               [ 'fugitivestatus', 'readonly', 'filename', 'modified' ] ]
        \   },
        \   'component_function': {
        \     'fugitivestatus': 'FugitiveStatusline'
        \   },
		\   'component': {
		\     'lineinfo': '%3l:%-2v',
        \   },
        \ }
    " }}}

    " Miscellaneous {{{
        let g:rainbow_active = 1
    " }}}
   
    " NERDTree {{{
        let NERDTreeHijackNetrw=1
        let NERDTreeMinimalUI=1
        let NERDTreeQuitOnOpen=1

        let g:NERDTreeMapOpenRecursively='T'
        let g:NERDTreeMapToggleHidden='.'

        let g:NERDTreeMapChangeRoot=v:null
        let g:NERDTreeMapChdir=v:null
        let g:NERDTreeMapCWD=v:null
        let g:NERDTreeMapDeleteBoomark=v:null
        let g:NERDTreeMapOpenInTab=v:null
        let g:NERDTreeMapOpenInTabSilent=v:null
        let g:NERDTreeMapPreview=v:null
        let g:NERDTreeMapRefreshRoot=v:null
        let g:NERDTreeMapToggleBookmarks=v:null
        let g:NERDTreeMapToggleFiles=v:null
        let g:NERDTreeMapToggleFilters=v:null
        let g:NERDTreeMapToggleZoom=v:null

        " My ideavim "nerdtree" uses <c-j>, <c-k>, etc. so I don't
        " have to use arrow keys. This creates same behavior here.
        autocmd FileType nerdtree
            \  map <buffer> <c-j> j
            \| map <buffer> <c-k> k
            \| map <buffer> <Esc> q

        "
        " Need to hook into both open and close to make sure the NERDTree
        " buffers are getting wiped out. The OpenNode mapping also ensures that
        " directories get opened in a new buffer (as opposed to just being
        " expanded in the current tree).
        "

        autocmd VimEnter * call NERDTreeAddKeyMap({
               \ 'key': '<CR>',
               \ 'callback': 'NERDTreeOpenNode',
               \ 'quickhelpText': 'Better directory open',
               \ 'scope': 'DirNode',
               \ 'override' : 1})

        function! NERDTreeOpenNode(node)
            execute 'bwipeout' 
            execute 'edit' . a:node.path.str()
        endfunction

        autocmd VimEnter * call NERDTreeAddKeyMap({
               \ 'key': 'q',
               \ 'callback': 'NERDTreeWipeout',
               \ 'quickhelpText': 'Close NERDTree buffer',
               \ 'scope': 'all',
               \ 'override' : 1})

        function! NERDTreeWipeout()
            execute 'bwipeout' 
        endfunction

        " Not sure why, but also need this.
        autocmd FileType nerdtree setlocal bufhidden=wipe

        "
        " The following is all to handle ':edit ~'
        "

        augroup explore
            autocmd!
            " autocmd BufEnter,BufWinEnter * call s:explore(expand('<amatch>'))
        augroup END

        function s:explore(path)

            let path = a:path
            if fnamemodify(path, ':t') ==# '~'
                let path = expand('~')
            endif

            if isdirectory(path) 
                call nerdtree#checkForBrowse(path)
            endif
        endfunction
    " }}}

    " Open-browser {{{
        let g:netrw_nogx = 1 " disable netrw's gx mapping.
        nmap gx <Plug>(openbrowser-smart-search)
        vmap gx <Plug>(openbrowser-smart-search)
    " }}}

    " Scratch {{{
        let g:scratch_no_mappings = 1
        nmap gs :<c-u>call scratch#open(0)<cr>
        xmap gs <plug>(scratch-selection-reuse)<cr>

        let g:scratch_height = 0.3
        let g:scratch_autohide = 0
        let g:scratch_insert_autohide = 0
        let g:scratch_persistence_file=$HOME . '/.scratch.vim'
    " }}}

    " SuperTab {{{
        " <c-space> is gobally mapped to :buffer#, but there seems
        " to be no conflict here.
        " let g:SuperTabMappingForward = '<c-space>'
        " let g:SuperTabMappingBackward = '<s-c-space>'
        "
        " let g:SuperTabDefaultCompletionType = "context"
        " let g:SuperTabContextDefaultCompletionType = "<c-n>"
    " }}}
    
    " VimWiki {{{
        
        " TODO: I'd like to switch this over to markdown syntax with '.md'
        " files, but that breaks things at the moment.
        
        nmap <leader>vw <Plug>VimwikiIndex
        let g:vimwiki_list = [{'path': '~/vimwiki/'}]
        " let g:vimwiki_list = [{'path': '~/vimwiki/',
        "                       \ 'syntax': 'markdown', 'ext': '.md'}]
    
        " By default, vimwiki uses <leader>w... for a number of key mappings.
        " I user <leader>w for write and want to avoid the key delay. So...

        " Disable all key mappings.
        let g:vimwiki_key_mappings = { 'all_maps': 0, }

        " Add the keys I want. I'm sure there will be others.
        autocmd FileType vimwiki setlocal textwidth=78
            \| nmap <buffer> <CR>        <Plug>VimwikiFollowLink
            \| nmap <buffer> <Backspace> <Plug>VimwikiGoBackLink
    " }}}
" }}}

" Functions {{{

    function! s:warn(message)
        echohl WarningMsg | echom a:message | echohl None
        return 0
    endfunction

    "
    " Find 'project' root dir, identified by list of file or dir markers.
    " Mostly exists for use with fzf.
    "
    function! s:ProjectRoot()
        " Dirs should end with a slash. Order is important... first find wins.
        let l:root_markers = ['.git/', '.svn/', 'build.gradle', 'pom.xml']

        for root_marker in l:root_markers
            if root_marker[-1:] == '/'
                let root_marker = root_marker[:-2]
                let l:project_root = finddir(root_marker, expand('%:p:h').';') 
            else
                let l:project_root = findfile(root_marker, expand('%:p:h').';') 
            endif

            if l:project_root != ''
                let l:project_root = fnamemodify(l:project_root, ':h')

                if l:project_root == '.'
                    let l:project_root = fnamemodify(l:project_root, ':p:h')
                endif

                return l:project_root
            endif
        endfor

        return ''
    endfunction

    " 
    " Dump output of an ex command to a new buffer in a new tab. Primarily
    " useful for searching ex command output.  
    " Example: :TabMessage map
    " 
    function! TabMessage(cmd)
      redir => message
      silent execute a:cmd
      redir END

      if empty(message)
        echoerr "no output"
      else
        " use "new" instead of "tabnew" below if you prefer split windows instead of tabs
        tabnew
        setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted nomodified
        silent put=message
      endif
    endfunction

    command! -nargs=+ -complete=command TabMessage call TabMessage(<q-args>)

    " 
    " Wanted to have <c-n> run invnumber and <c-r> run invrelativenumber so I
    " could toggle these independently, but <c-r> is redo and I didn't want to
    " mess with that. With this function I can just cycle through using a
    " single key.
    "
    function! CycleNumber() 
        if ! &number && ! &relativenumber
            set number
        elseif &number && ! &relativenumber
            set relativenumber
        else
            set nonumber
            set norelativenumber
        endif
    endfunction
" }}}

" TODO / etc {{{
"
"   - Snippets
"
"   - Tags
"
"   - Copy character from line above/below?.
"
"   - I have some diff mode stuff configured here (see the VimDiff and windo
"   keymappings above). It would be nice if we did a 'diffoff' while in a Vim
"   Fugitive diff, that we delete the git index buffer.
"
"   - Some interesting things I see in Nate Neff's vim github project:
"
"     <Space>    Show recent buffers at bottom of screen.
"                Use 'f' and 'b' to move back & forth between them.
"                Thanks to bufmru plugin author!
"
"     # NERD Commenter
"     
"      <leader>ci      Comment / Uncomment line(s)
"      <leader>cu      UN-comment line(s)
"      <leader>cl      Comment lines
"     
" }}}

" I (or preceeding blank) am only here to ensure last fold doesn't misbehave.
