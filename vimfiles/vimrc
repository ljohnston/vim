"
" TODO {

"   - Refactor/Reformat.
"
"   - I use C-L and C-H to go back and forth between buffers.
"   When I hit a netrw buffer, however, these keys are remapped to
"   something else. Ideally, I'd like the netrw buffer to just go
"   away when I select a file.
"
"   - How can I "close" a netrw buffer (:bd doesn't even work!).
"
"   - Figure out how to get :bnext, :bprev to ignore directory buffers.
"   If I do this, would also want to figure out how to get buftabs to
"   not include directory tabs in its list.
"
"   - buftabs might be cool (I tried it for a while), but I can't get it 
"   to restore the status line after switching tabs (which it claims is
"   the standard behavior). Also, I can't get it to sort the buffers
"   (ideally, I'd like it to be mru).
"
"   - Groovy (gradle) syntax highlighting, indenting. Currently this pretty
"   much sucks. Added the groovy.vim for indenting, but doesn't seem to do
"   _anything_. I'll leave it here, but this needs to be dealt with.
"
"   - Copy character from line above (below?).
"
"   - Need a keystroke to go to matching paren (or...). Default is %.
"   FIXED: Mapped it to tab.
"
"   - Fix issue with ';' after a 'f' waiting for the leader delay.
"   FIXED: Had key maps that started with ';' (FormatCss()). Changed
"   the key mapping.
"
"   - Need to setup some keystrokes and/or function for using diff while
"   in vim. Vim can do this no problem, but the user experience is kind
"   of a pain in the ass. Here's (one way) how it works:
"     - open two buffers in vertical or horizontal split
"     - go to one buffer and do ':diffthis'
"     - go to other buffer and do ':diffthis'
"     - do your merges/edits (]c, [c to jump diffs, :diffget, :diffput
"     to merge across buffers
"     - go to one buffer and do ':diffoff'
"     - go to other buffer and do ':diffoff'
"   Wow, really? That kinda sucks. Here's my wishlist:
"     - if in a split, keystroke will start diff for the two buffers in
"     the split
"     - if NOT in a split, keystroke will ~horizontally~ extend the
"     window and open the prior buffer in a vertical split
"     - while in the diff, a keystroke will turn off diff in both buffers,
"     closing the split (~ideally~ only if it opened the split to begin)
"     - while in diff mode, some handy dandy keystroke mappings would be
"     nice
"
"   - Add keystroke/functionality to insert a snippet for my code section
"   "headers". For example:
"
"   //----------------------------------------------------------------------
"   // [some text]
"   //----------------------------------------------------------------------
"
"   Hmmm... how to get comment characters for the above?
"
"   - plugins to look at:
"     - snipmate/ultisnips/neosnippet or something similar
"     - personal wiki (mostly for note taking, searching, etc. - looked at
"     xolox/notes.vim... no good)
"     - nerd-commenter (or something like it)
"     - fugitive (git plugin)
"     - yankring or yankstack (or will unite suffice?)
"
"   - Really need to get netrw whipped into shape, which seems to be
"     a much bigger pain in the ass than it should be. From this link...
"
"     http://vim.1045645.n5.nabble.com/Getting-out-of-netrw-td1156403.html
"
"     ... some things that might be useful:
"
"     function MyExplore()
"       tabnew
"       Explore
"       nmap <buffer> <leader>q :q<cr>
"     endfunction 
"
"     Run this ':topleft vsplit .'
"
"     And from...
"
"       http://stackoverflow.com/questions/21996768/how-do-you-change-the-root-of-the-netrw-tree-in-vim
"
"     ... when in tree mode, you can use :Ntree to reset the head of the
"     tree.
"
"   - Some interesting things I see in Nate Neff's vim github
"     project:
"
"     <Space>    Show recent buffers at bottom of screen.
"                Use 'f' and 'b' to move back & forth between them.
"                Thanks to bufmru plugin author!
"
"     # NERD Commenter
"     
"      <leader>ci      Comment / Uncomment line(s)
"      <leader>cu      UN-comment line(s)
"      <leader>cl      Comment lines
"     
"     # Source Control
"     
"     (From VCSCommand.vim)
"     
"      <leader>nvc     Commit current file
"      <leader>nvd     Diff current file w/repository version
"      <leader>nvv     VimDiff current file w/repository version
"     
" }
"

"
" DEBUGGING/TROUBLESHOOTING - Can use 'echom "<msg>" for messages that
" may show up in the cmd window (if it exceeds cmdheight) and/or can be 
" displayed with :messages.
"

if has('vim_starting')
   set nocompatible

   " Required:
   set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

" Required:
call neobundle#begin(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'
        
" Bundles here:
"NeoBundle 'Shougo/neosnippet.vim'
"NeoBundle 'Shougo/neosnippet-snippets'
NeoBundle 'bling/vim-airline', { 'rev' : 'v0.7' }
NeoBundle 'jeetsukumaran/vim-buffergator', { 'rev' : 'v2.4.1' }
NeoBundle 'luochen1990/rainbow.git', { 'rev' : 'v3.3.1' }
NeoBundle 'ervandew/supertab.git', { 'rev' : '2.1' }
NeoBundle 'scrooloose/syntastic', { 'rev' : 'v0.5.7' }
NeoBundle 'tpope/vim-surround.git', { 'rev' : 'v2.0' }

" Installed vim-misc because it's required by vim-notes.
" TODO: Not diggin' this plugin. Replace with a personal wiki plugin?
NeoBundle 'xolox/vim-notes.git', { 'rev' : '0.26' }
NeoBundle 'xolox/vim-misc.git', { 'rev' : '1.15' }

" On OS X install ag (a.k.a the silver searcher) to enhance performance 
" (unite detects it automatically). Can be installed via brew.
"NeoBundle 'Shougo/unite.vim', { 'rev' : 'ver.6.1' }
NeoBundle 'Shougo/unite.vim'

" Installed this for unite.vim async features, but I think there
" are other plugins that use this if installed.
NeoBundle 'Shougo/vimproc.vim', {
\ 'build' : {
\     'windows' : 'tools\\update-dll-mingw',
\     'cygwin'  : 'make -f make_cygwin.mak',
\     'mac'     : 'make -f make_mac.mak',
\     'linux'   : 'make',
\     'unix'    : 'gmake',
\    },
\ }

" These plugins don't have tags. :-(
NeoBundle 'rodjek/vim-puppet.git'
NeoBundle 'godlygeek/tabular.git'
NeoBundle 'flazz/vim-colorschemes.git'
NeoBundle 'vim-scripts/scratch.vim.git'
NeoBundle 'dbakker/vim-projectroot.git'

" Even worse, these plugins have tags, but they're ~way~ out of date. >:-(
NeoBundle 'tpope/vim-abolish'

call neobundle#end()

" Required:
filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck

"echom "unix:" . has('unix') 
"echom "mac:" . has('mac') 
"echom "gui_running:" . has('gui_running') 
"echom "gui_macvim:" . has('gui_macvim') 

"
" TODO: Refactor this. Needs to be up here so it's available when
" we need it.
"
" LOJ: Got the following colorscheme stuff from:
"
" https://github.com/megaannum/colorschemer/blob/master/autoload/colorschemer/viewer.vim
"

" used to capture the Color Scheme name in GetColorSchemeName
let s:colorsname = ""

"---------------------------------------------------------------------------
" s:GetColorSchemeName: {{{3
" Returns the current Color Scheme name.
" If g:colors_name exists, then return it otherwise return
" the result of the the command line: colorscheme.
" parameters: None
"---------------------------------------------------------------------------
function! s:GetColorSchemeName()
  if exists("g:colors_name")
    return g:colors_name
  else
    if exists("s:colorsname")
      unlet s:colorsname
    endif

" capture result of executing ":highlight"
    execute "redir => s:colorsname"
    silent execute "colorscheme"
    execute "redir END"
    let s:colorsname = s:colorsname[1:]
    return s:colorsname
  endif
endfunction

" General {
    syntax on

    filetype plugin indent on

    set ttyfast "fast terminal connection

    " (Mostly) bash-like autocompletion.
    set wildmenu
    set wildmode=longest,list,full

    set backspace=indent,eol,start "a better backspace
    set fileformats=unix 
    set hidden "change buffers without saving

    set history=100

    set ignorecase
    set smartcase
    set incsearch
    set showmatch

    " Detect external file changes
    set autoread

    " Silence the damn bell
    "set noerrorbells 
    "set visualbell
    "set t_vb=
    set noerrorbells visualbell t_vb=
    autocmd GUIEnter * set visualbell t_vb=

    " This will help keep netrw from displaying the annoying
    " 'Press ENTER or type command to continue' prompt all the time.
    " This solution, however, is generally annoying.
    set cmdheight=3

    " This seems to cause problems in console vim.
    "if exists('+autochdir')
    "  set autochdir "always switch to current buffer directory 
    "endif
    autocmd BufEnter * silent! lcd %:p:h

    "System clipboard integration.
    if has('unix') && exists('+xterm_clipboard')
        set clipboard+=unnamedplus
    else
        set clipboard+=unnamed
    endif

    if has('unix') || has('gui_macvim') 
        " Removing this from the list first will ensure it gets
        " pre-pended to the list in the ^= line (if it's already
        " anywhere in the list that line is a no-op).
        set directory-=~/tmp
        set directory^=~/tmp//

        set backupdir-=~/tmp
        set backupdir^=~/tmp//
    endif
" }



" UI {
    set hlsearch
    set ruler "show cursor position
    set scrolloff=3 "context lines when scrolling
    set sidescrolloff=5 "context columns when scrolling
    set guioptions-=T "turn off the toolbar

    set laststatus=2 "always show status line
    set showmode "display mode at bottom of screen
    set showcmd "show useful stuff at bottom of screen
    
    " cursor movement
    set nostartofline
    set virtualedit=all
" }



" Formatting {
    set expandtab
    set shiftwidth=4
    set softtabstop=4
" }



" Autocommands {
    " Ruby {
        " ruby standard 2 spaces, always
        au BufRead,BufNewFile *.rb,*.rhtml setlocal shiftwidth=2 
        au BufRead,BufNewFile *.rb,*.rhtml setlocal softtabstop=2 
    " }

    " gradle {
        au BufNewFile,BufRead *.gradle setf groovy
    " }
    
    " shell scripts {
    "    autocmd FileType sh setlocal shiftwidth=2
    "    autocmd FileType sh setlocal softtabstop=2
    " }

    " reread .vimrc on save
    au! BufWritePost .vimrc source % 

    "
    " wrap lines in .txt files.
    " When writing text-based documentation, automatically wrap text.
    " Ideally _don't_ wrap text for entering strings to be entered on
    " the command-line. We should be able to achieve this by setting
    " # and $ as comment characters and not including 'c' in the
    " formatoptions. Looks like I may be understanding this incorrectly
    " and it may not be possible. Rather it appears that 't' is _all_
    " text (including comments), and 'c' is comments only.
    "

    au BufRead,BufNewFile *.txt setlocal textwidth=72
    au BufRead,BufNewFile *.txt setlocal formatoptions=tq

    "
    " Turn off handling of '-' as a bullet (sort of).
    " Without this, we get (for wrapped lines):
    " - some text ...
    "   another line ...
    " yet another line.
    "
    " Note that we can get _all_ of the above lines to indent within
    " the paragraph by setting 'autoindent'.
    "

    au BufRead,BufNewFile *.txt setlocal comments-=fb:-
"}


let g:airline_powerline_fonts = 1
let g:airline_theme = 'bubblegum'


" Buffergator {

    " Don't allow buffergator to extend window.
    let g:buffergator_autoexpand_on_split = 0

    " Sort buffer list.
    "let g:buffergator_sort_regime = "basename"
    "let g:buffergator_sort_regime = "filepath"
    let g:buffergator_sort_regime = "mru"

    " Though I'd prefer the viewport on the left, it's not
    " wide enough (nor is it practical to _make_ it wide enough)
    " to show full file details.
    let g:buffergator_viewport_split_policy = "T"
    let g:buffergator_split_size = 15

    " TODO: Unmap buffergator's tab handling keys.
" }


" Netrw {
    let g:netrw_keepdir = 0
    let g:netrw_special_syntax = 1
" }


" SuperTab {
    "let g:SuperTabDefaultCompletionType = '<c-n>'
    let g:SuperTabDefaultCompletionType = "context"
    let g:SuperTabContextDefaultCompletionType = "<c-n>"
" }

" Syntastic {
"    let g:syntastic_enable_signs=1
" }


" Keys {

    "
    " NOTE: Many keys in vim are not mapable. For example, would like to 
    " have keys for the following, but these particular keys (and several 
    " others) can't be remapped. More here:
    "
    " http://vim.1045645.n5.nabble.com/How-to-map-Ctrl-td1192843.html
    "
    "map <C-,> #
    "map <C-.> *
    "nnoremap <C-/> :bdelete<cr>
    
    let mapleader = "\<Space>"
    let g:mapleader = "\<Space>"

    " Write buffers.
    nmap <leader>w :w!<cr>
    nmap <leader>W :wa!<cr>

    "
    " <C-o> instead of escape to reduce side-effects. More here:
    "
    "   http://vim.wikia.com/wiki/Use_Ctrl-O_instead_of_Esc_in_insert_mode_mappings
    "
    " Really wanted this to be ctrl-i, but vim sees that the same as tab.
    "
    
    nmap <C-s> :set cursorcolumn!<cr>
    imap <C-s> <C-o><C-s>

    " <tab> to move to matching paren, bracket, etc., but
    " ~only~ in normal and visual modes.
    nmap <tab> %
    vmap <tab> %
    
    " Toggle line numbers.
    nmap <C-n> :call CycleNumber()<cr>
    imap <C-n> <C-o><C-n>

    " Buffer switching (Buffergator here as :bp and :bn don't honor mru).
    nmap <C-l> :BuffergatorMruCycleNext<cr>
    nmap <C-h> :BuffergatorMruCyclePrev<cr>

    " Turn current highlight off.
    nmap <silent> <leader>/ :noh<cr>

    nmap <leader>e :Explore<cr>

    " Search for my section headers.
    nmap <leader>s /^.*-\{40,80}\n^.*\[.*\]\s*\_.\{-}-\{40,80}\s*$<cr>
" }



" GUI {
    if has("gui_running")

        set background=light

        "colorscheme candy 
        colorscheme molokai 

        let cname = s:GetColorSchemeName()

        if cname == 'molokai'
    
            " Seems most colorschemes use crappy cursor line colors.
            highlight CursorLine guibg=Gray30
            highlight CursorColumn guibg=Gray30
            highlight ColorColumn guibg=DarkSlateGray
    
            " molokai's comments are too dark.
            highlight Comment guifg=SkyBlue3
    
            " molokai's visual selection needs more contrast.
            highlight Visual guifg=Gray30 guibg=NavajoWhite

        endif

        let g:rainbow_active = 1 "if 0, can be enabled later via :RainbowToggle

        " 
        " For a good resource regarding how to pic and set a font, see:
        "
        "   http://www.scholarslab.org/grad-student-research/vim-gui-font-magic/
        "
        
        "
        " NOTE: 'gui_macvim' and 'unix' are not exclusive (i.e. 
        " has('gui_macvim') also has('unix')).
        "

        if has('gui_macvim') 
            set transparency=10
            set guifont=Sauce\ Code\ Powerline:h14
            set columns=120
            set lines=52
        elseif has('unix') 
            set guifont=Source\ Code\ Pro\ for\ Powerline\ Medium\ 10
            set columns=120
            set lines=52
        else
            set guifont="Courier 10 Pitch":h10
            set columns=120
            set lines=64
        endif

        " This is primarily to keep buffergator (assuming it comes up
        " on the left side of the screen... which it does) from adding
        " a scrollbar to its window.
        set guioptions-=L
    
        " hightlight current line
        set cursorline

        set colorcolumn=81
    endif
" }


"
" Wanted to have something I could use to go to the last visited
" buffer (so I could map to a single key to bounce back and forth 
" between the two most recent buffers). Way harder than I expected.
" Abandoning this for now, but holding onto it just in case I want
" to revisit.
"
"let g:toggle_buffer_next = 0
"
"function! ToggleMruBuffer()
"    if g:toggle_buffer_next
"        silent! BuffergatorMruCycleNext
"        if &buftype == 'nofile'
"            ToggleMruBuffer() 
"        endif
"        let g:toggle_buffer_next = 0
"    else
"        silent! BuffergatorMruCyclePrev
"        if &buftype == 'nofile'
"            ToggleMruBuffer() 
"        endif
"        let g:toggle_buffer_next = 1
"    endif
"endfunction

"------------------------------------------------------------
" [Unite]
"------------------------------------------------------------
"
" I don't really understand how to use this plugin, some things
" I've done:
"
" Grep cursor word from file's subdir:
"   UniteWithCursorWord -silent -auto-preview -winheight=40 -no-quit grep
" Grep cursor work from project root:
"   UniteWithCursorWord -silent -auto-preview -winheight=40 -no-quit grep:!
"

"
" I created this function so I could have more control over the project
" root (the projectroot plugin is more customizable than unite's project
" root handling). This was primarily to get around the svn 1.6 client
" behavior of puppet a .svn directory at every level. After switching 
" to the svn 1.8 client, however, this was no longer an issue. Will
" keep this around in case I run into other limiations.
"
"function! Unite_projectRoot(args)
"    execute ':Unite ' . a:args . ':' . projectroot#guess() 
"endfunction
"
" Use the above as follows:
"nnoremap <leader>f :call Unite_projectRoot("-buffer-name=files -start-insert buffer file_rec/async")<cr>
"

"
" Most of this configuration, and more good stuff (I think) from:
" http://www.codeography.com/2013/06/17/replacing-all-the-things-with-unite-vim.html
"

let g:unite_source_history_yank_enable = 1

" NOTE: '!' means project dir.

nnoremap <leader>F :<C-u>UniteWithProjectDir -buffer-name=files -start-insert file_rec/async<cr>
nnoremap <leader>f :<C-u>Unite -buffer-name=files -start-insert file_rec/async<cr>
nnoremap <leader>G :<C-u>Unite -buffer-name=grep -start-insert grep:.<cr>
nnoremap <leader>g :<C-u>Unite -buffer-name=grep -start-insert grep:!<cr>
nnoremap <leader>y :Unite history/yank<CR>

call unite#custom#source(
            \ 'file_rec,file_rec/async', 
            \ 'ignore_pattern', 
            \ '\(\.svn\|\.git\|\.gradle\)')

call unite#custom#source(
            \ 'file', 'matchers',
            \ ['matcher_default', 'matcher_hide_hidden_files',
            \  'matcher_hide_current_file'])

if executable('ag')
    let g:unite_source_grep_command='ag'
    let g:unite_source_grep_default_opts =
                \ '-i --line-numbers --nocolor --nogroup --hidden --ignore ' .
                \  '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.gradle'' --ignore ''.bzr'''
    let g:unite_source_grep_recursive_opt=''
    let g:unite_source_rec_async_command =
                \ 'ag --follow --nocolor --nogroup --hidden -g ""'
elseif executable('ack')
    let g:unite_source_grep_command='ack'
    let g:unite_source_grep_default_opts='--no-heading --no-color -a'
    let g:unite_source_grep_recursive_opt=''
    let g:unite_source_rec_async_command = 'ack -f --nofilter'
endif

" Custom mappings for unite buffers
autocmd FileType unite call s:unite_settings()
function! s:unite_settings()
  " Play nice with supertab
  let b:SuperTabDisabled=1

  " Enable navigation with control-j and control-k in insert mode
  imap <buffer> <C-j>   <Plug>(unite_select_next_line)
  imap <buffer> <C-k>   <Plug>(unite_select_previous_line)
  imap <buffer> <C-q>   <Plug>(unite_exit)
endfunction

"------------------------------------------------------------
" [Utility functions]
"------------------------------------------------------------

"
" Wanted to have <c-n> run invnumber and <c-r> run invrelativenumber
" so I could toggle these independently, but <c-r> is redo and I didn't
" want to mess with that. With this function I can just cycle through
" using a single key.
"

function! CycleNumber() 
    if ! &number && ! &relativenumber
        set number
    elseif &number && ! &relativenumber
        set relativenumber
    else
        set nonumber
        set norelativenumber
    endif
endfunction


function! OverwriteCharAbove()
    k y l
    j
    P
endfunction
"nmap <silent>  ;t  :call OverwriteCharAbove()<CR>

function! FormatCss()

    " TODO: Make sure we're in css buffer?

    "
    " Decontstruct the file to a consistent format from which
    " we can reliably reconstruct it.
    "

    silent %s///g                       " Just in case, delete any control-M's.
    silent %s/\s*$//g                     " Remove trailing whitespace on all lines.
    silent %s/\s\+/ /g                    " Replace multiple whitespace with single space.
    silent g/^\s*$/d                      " Delete all blank lines.
    silent %s/\n//g                       " Remove all carriage returns.

    "
    " Reformat the deconstructed file.
    "
    
    silent %s/\*\//*\/\r\r/g              " Two newlines after comment lines.
    silent %s/}/}\r\r/g                   " Two newlines after }.
    silent %s/{/{\r/g                     " Newline after {.
    silent %s/;/;\r/g                     " Newline after ;.
    silent %s/^\(\s*\S\+.*\)}$/\1\r}/g    " Newline before ).

    " TODO: There's a potential issue with sorting attributes in
    " that the original css could have multiple attributes, with
    " the last one not being terminated with a ';'. In this case,
    " sorting could move that attribute to the middle of the list,
    " which, without the ';', would be invalid html. Therefore,
    " we'll simply return here until we account for this.

    return

    "
    " Sort attributes.
    "

    " Start at top of file.
    normal gg

    while search("{$", "W")
        +1
        let first = line(".")

        /}
        -1
        let last = line(".")

        execute first . "," . last . "sort"
    endwhile

    " Indent file.
    normal gg=G

endfunction

nmap <silent> _c :call FormatCss()<CR>

